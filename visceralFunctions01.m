(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Visceral Growth: Catenary Curve


BeginPackage["VisceralFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


VisceralFunctions::usage="This package is where the new plate addition functions are stored.";


CatEqn::usage="it is a function defines the catenary curve, a is a constant";


CatLength::usage="calculates the length of the curve between two points";


GetConst::usage="it is a funcion that calculates the constant for the catneray curve given the parameters";


AmbdiametLengthR::usage="this defines the relationship between the length of the column and the ambitus diameter of the test";


GetCatenaryCurve::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


GetCatenaryCurve4::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


CreateCatCurve3D::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


CreateCatCurve::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


CreateCatCurveNoL::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


CreateCatCurveList::usage="it is a function that calculates the constant, length and returns data for the curvature of the test";


Begin["`Private`"]


CatEqn[x_,a_]:=a Cosh[(x/a)]-a


CatLength[pts_,a_]:=Module[{x},
catf[x_]=a Cosh[x/a]  - a;
NIntegrate[Sqrt[1+(catf'[x])^2],{x,pts[[1]],pts[[2]]}]
]


GetConst4[fp_]:=ct/.FindFit[fp,ct Cosh[x/ct]-ct ,{ct},x,MaxIterations-> 100000000000000000]


GetX[a_,ramb_,pc_]:=ct/.FindRoot[a Cosh[ct/a]  -a==ramb,{ct,pc},MaxIterations-> 100000000000000000]


AmbdiametLengthR[cl_]:=cl


GetCatenaryCurve[pc_,cl_,ap_,p_]:=Module[{ramb,a,hOfC,apL,pL ,datas},
ramb=AmbdiametLengthR[(cl-ap-p)]/2;
hOfC=(cl-ap-p)*pc/2;
a=GetConst4[{{hOfC,ramb},{-hOfC,ramb},{0,0}}];
apL=GetX[a,(ramb-ap),0.001];
pL=GetX[a,(ramb-p),-cl];
{a,ramb,EuclideanDistance[{apL,0},{pL,0}],CatLength[{pL,apL},a],Sort[{pL,apL}],Sort[{(ramb-ap),(ramb-p)}],{{-hOfC,ramb},{0,0},{hOfC,ramb}},{{apL,(ramb-ap)},{pL,(ramb-p)}},1-(Abs[(CatLength[{pL,apL},a]-(cl-ap-p))]/(cl-ap-p)),CatLength[{pL,apL},a],(cl-ap-p),pc,EuclideanDistance[{apL,0},{pL,0}]}
]



GetCatenaryCurve4[pc_,cl_,ap_,p_]:=Module[{ramb,a,hOfC,apL,pL ,datas},
ramb=AmbdiametLengthR[(cl)]/2;
hOfC=(cl/2)*pc;
a=GetConst4[{{hOfC,ramb},{-hOfC,ramb},{0,0}}];
apL=GetX[a,(ramb-ap),0.001];
pL=GetX[a,(ramb-p),-cl];
{a,ramb,EuclideanDistance[{apL,0},{pL,0}],CatLength[{pL,apL},a],Sort[{pL,apL}],Sort[{(ramb-ap),(ramb-p)}],{{-hOfC,ramb},{0,0},{hOfC,ramb}},{{apL,(ramb-ap)},{pL,(ramb-p)}},1-(Abs[(CatLength[{pL,apL},a]-(cl))]/(cl)),CatLength[{pL,apL},a],(cl),pc,EuclideanDistance[{apL,0},{pL,0}]}
]



CreateCatCurve3D[catinfo_]:=Module[{m},
RevolutionPlot3D[{CatEqn[m,catinfo[[1]]]-catinfo[[2]],m},{m,catinfo[[5,1]],catinfo[[5,2]]},{t,-2Pi,2Pi},Axes->False,Boxed->False]
]


CreateCatCurve[catinfo_]:=Module[{m},
Show[ListPlot[Table[{CatEqn[m,catinfo[[1]]],m}, {m,catinfo[[5,1]],catinfo[[5,2]],0.01}],Axes->False,Joined->True,AspectRatio->1,PlotStyle->{Directive[PointSize[0.007],Black,Thickness[0.006]]},
AxesStyle->Directive[Black,FontSize->38.,FontFamily->"Arial", Thickness[0.0035]]],Graphics[{Line[{{catinfo[[2]],-catinfo[[3]]/2},{catinfo[[2]],catinfo[[3]]/2}}],AspectRatio->1}]]
]


CreateCatCurveNoL[catinfo_]:=Module[{m},
ListPlot[Table[{CatEqn[m,catinfo[[1]]],m}, {m,catinfo[[5,1]],catinfo[[5,2]],0.01}],Axes->False,Joined->True,AspectRatio->1,PlotStyle->{Directive[PointSize[0.007],Black,Thickness[0.006]]},
AxesStyle->Directive[Black,FontSize->38.,FontFamily->"Arial", Thickness[0.0035]]]
]


CreateCatCurveList[catinfo_]:=Module[{m},
{ListPlot[Table[{CatEqn[m,catinfo[[1]]],m}, {m,catinfo[[5,1]],catinfo[[5,2]],0.01}],PlotStyle->{Directive[PointSize[0.007],Black,Thickness[0.006]]},
AxesStyle->Directive[Black,FontSize->38.,FontFamily->"Arial", Thickness[0.0035]],Axes->False,Joined->True,AspectRatio->1],Graphics[{Line[{{catinfo[[2]],-catinfo[[3]]/2},{catinfo[[2]],catinfo[[3]]/2}}],AspectRatio->1}]}
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
