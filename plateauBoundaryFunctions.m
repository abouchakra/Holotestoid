(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Plateau's Boundary


Needs["SmallFunctions`"]


Needs["FermatPointFunctions`"]


BeginPackage["PlateauBoundaryFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


PlateauBoundaryFunctions::usage="This package is where all the distance calculating functions are stored.";


FindCenterOfCurvature::usage="finds the location or the center point for the circle of curvature between two bubble";


CircleBoundaryFunction::usage="finds the arc created from the intersection between two bubbles and the circle of curvature";


GetCurvatureOfBoundary::usage="finds curvature of boundary inforation for a pair of bubbles";


TwoBubbleBoundaryInteraction::usage="finds and updates the bubbles list for boundary information";


GetPlateauBoundary::usage="gets the boundary between all the pairs in a column";


ReplacePoint::usage="replaces the correct intersection point and gets the new angles for the arc";


GetInterBorders::usage="gets the boundaries shared between the triplet";


GetAllBorderIntersection::usage="each boundary info contains the center position of the plate at that time...so it finds all the boudary at a time and their intersection points to define the plate";


FindPlateauBoundary::usage="each boundary info contains the center position of the plate at that time...so it finds all the boudary at a time and their intersection points to define the plate";


Begin["`Private`"]


Gets the boundaries


FindCenterOfCurvature[rLarge_,rSmall_,oneBubble_,d_,dd_,bsize_]:=Module[{rc, ac,nac},
(* based on the equation 1/rsmall= 1/rLarge +1/rc*)
rc = 1/(1/rSmall-1/rLarge);
ac = SmallFunctions`CenterDistance[rLarge, rc,Pi*120/180];
(*using similar triangle ratio*)
nac = ac*d/dd;
(* take the larger and add the distance to it away from the smaller bubble, because the circle of curvature is not adjacent to the larger bubble*)
{( oneBubble+({bsize,bsize}*nac)),rc,ac}
]


CircleBoundaryFunction[circleOfcurvature_, intersectionPts_]:=Module[{ang,cenQuad,m,l,sm1,quadPos},
 (*i need this to know the slope and angle direction the plate is located in order to draw the border*)
(*finds the slope between the center of curvature and each intersection points*)
sm1= SmallFunctions`Slopedirec[#,circleOfcurvature[[1]]]&/@intersectionPts;
(*finds the angle for each slope*)
ang =If[#=={0,0},0,ArcTan[#[[1]],#[[2]]]]&/@sm1;
(* i needed to find which quadrant the points were located relative to the center of curvature*)
(*this was necessary because i had to control the direction the boudary was drawn*)
quadPos=SmallFunctions`QuadAngle[SmallFunctions`AngleAroundThePlate[#]]&/@sm1;
(*only interaction between my 1 (bottom left) and 4th(top left) quadrants  needed the angles to be adjusted so it draws the closest line and not a large arc..i still need something to detrmine the direction of the arc if the quads are {1,2},{3,4}*)
cenQuad=SmallFunctions`QuadAngle[SmallFunctions`AngleAroundThePlate[ SmallFunctions`Slopedirec[circleOfcurvature[[3]],circleOfcurvature[[1]]]]];
m=Sort[quadPos];
l=Sort[ang];
Which[
((m=={1,3})&& (cenQuad==4)),l={l[[2]],(2Pi)+l[[1]]};,
((m=={2,4})&& (cenQuad==1)),l={l[[2]],(2Pi)+l[[1]]};,
m=={1,4},l={l[[2]],(2Pi)+l[[1]]};
];
(*returns the center, raduis and angles, they are used in the circle function,Circle[{x, y}, r, {Subscript[\[Theta], 1], Subscript[\[Theta], 2]}]represents a circular arc.*)
{circleOfcurvature[[1]],circleOfcurvature[[2]],l}
]


GetCurvatureOfBoundary[pbubbles_]:=Module[{rA1,rB2,ncen,dd,d,inPts,fc,curveInfo},
rA1=pbubbles[[1,2]];
rB2 =pbubbles[[2,2]];
ncen = {pbubbles[[1,1]],pbubbles[[2,1]]};
(*this is the actual distance they are apart from each other..at this time they are definitely touching*)
dd=SmallFunctions`DistancebtwPoints[ncen[[1]],ncen[[2]]];
(*finds the slope*)
d = ncen[[2]]-ncen[[1]];
(*gets the intersection points after bubbles interact*)
inPts=SmallFunctions`IntersectionBoundaryPoints[{2,1,ncen[[1]],rA1},{2,1,ncen[[2]],rB2}];
If[inPts=={},
{}
,
(*finds the center of curvature*)
If[rA1 == rB2,
(*if both radii of the bubbles are the same, then the boundary will be straight*)
 {1,inPts,inPts[[1]]-inPts[[2]]}
,
(*direction of Curvature changes depending on which bubble is the smaller one*)
(*usually the larger has lower pressure and thus the smaller will cause is the concave*)
fc =(FindCenterOfCurvature[#[[1]],#[[2]],#[[3]],d,dd,#[[4]]])&@If[rA1 > rB2,{rA1,rB2,ncen[[1]],1},(*rb2>ra1*){rB2,rA1,ncen[[2]],-1}];
(*gets the angles so that the circle fuction can draw the arcs*)
curveInfo = CircleBoundaryFunction[{fc[[1]],fc[[2]],pbubbles[[1,1]]},inPts];
{2,inPts,curveInfo[[1]],curveInfo[[2]],curveInfo[[3]]}
](*returns the new information for the boundary*)
]
]


Clear[prepForInteracting]
(*it takes the full list and the location of the plates , compares the two bubbles and updates location*)
prepForInteracting[oldPlate_, newPlate_  ,opt_]:= Module[{plate1,plate2},
plate1 =oldPlate;
plate2=newPlate;
(* i still need to determine how to add genital and occular plates*)
If[opt ==1, 
plate1[[2]]=SmallFunctions`MyaveFn[plate1[[2]]];
plate2[[2]]=SmallFunctions`MyaveFn[plate2[[2]]];
,
(*I still need to find the radiiloc..determine which radii to use, do # sides = radiiloc*)
radiiLoc={1,2};
plate1[[2]]=plate1[[2,radiiLoc[[1]]]];
plate2[[2]]=plate2[[2,radiiLoc[[2]]]];
];
{plate1,plate2}
]


TwoBubbleBoundaryInteraction[allPlateList_,posPlate_  ,opt_]:=Module[{ newList,plateNum, plate1, plate2,tBubbles,temp},
If[(posPlate[[1]]=={})||(posPlate[[2]]=={}),newList=allPlateList;,
newList=allPlateList;
plateNum=SmallFunctions`NumOfPlates[newList];
plate1 =newList[[posPlate[[1,1]],posPlate[[1,2]]]];
plate2=newList[[posPlate[[2,1]],posPlate[[2,2]]]];
tBubbles=prepForInteracting[plate1, plate2  ,opt];
(* it determines the intersections and the boundary between each the plates*)
temp = GetCurvatureOfBoundary[tBubbles];
If[temp=={},
newList=allPlateList;
,
If[Length[plate1]==3, AppendTo[plate1,{}];];
If[Length[plate2]==3, AppendTo[plate2,{}];];
AppendTo[plate1[[4]],Join[temp,{{plate1[[1]],plate2[[1]]},posPlate,plateNum}]];
AppendTo[plate2[[4]],Join[temp,{{plate1[[1]],plate2[[1]]},posPlate,plateNum}]];
newList[[posPlate[[1,1]],posPlate[[1,2]]]] = plate1;
newList[[posPlate[[2,1]],posPlate[[2,2]]]]=plate2;
];
];
newList
]


GetPlateauBoundary[allBubbleList_,neighPairs_, opt_:1]:=
Module[
{newList},
newList=allBubbleList;
(newList=TwoBubbleBoundaryInteraction[newList,#  ,opt])&/@neighPairs;
newList
]


Intersects the boundaries


ReplacePoint[borderList_, posL_, newInt_]:=Module[{newBo,newAng},
newBo=borderList;
newBo[[posL]]=ReplacePart[newBo[[posL]],newInt,2];
If[newBo[[posL,1]]==2,
newAng=CircleBoundaryFunction[{newBo[[posL,3]],newBo[[posL,4]],newBo[[posL,6]][[1]]},newBo[[posL,2]]];
newBo[[posL,5]]=newAng[[3]];
];
newBo
]


GetInterBorders[neT_,bordList_]:=Module[{newB},
newB={};Map[Function[dummy2,If[If[dummy2[[1]]==1,MemberQ[neT,dummy2[[5]]]==True,MemberQ[neT,dummy2[[7]]]==True],AppendTo[newB,If[dummy2[[1]]==1,{dummy2[[5]],dummy2},{dummy2[[7]],dummy2}]];];],bordList,{2}];
Map[Last,Union[newB]]
]



GetAllBorderIntersection[tripPair_, allBubbleList_,fixedBorderList_]:=Module[{newBubbleList,pPos,b2,fPt,plateList,neT, newPt,newB,ptInt,posList,bordPos,finalInt,numberB,temp,upDateBorder,newBB2,anotherBubList,anothernewB,bd1Pos,anB},
newBubbleList=allBubbleList;
anotherBubList=fixedBorderList;
If[Length[tripPair]==3,
neT=Map[Sort,{{tripPair[[1]],tripPair[[2]]},{tripPair[[1]],tripPair[[3]]},{tripPair[[2]],tripPair[[3]]}}];
plateList=newBubbleList[[#[[1]],#[[2]]]]&/@tripPair;
b2=Map[Last, plateList];
newB=GetInterBorders[neT,b2];
anB=Map[Last,newB];
If[Length[Union[anB]]==1,newB=newB;,numberB=Last[Last[Sort[Map[Function[dummy,{Count[anB,dummy],dummy}],Union[anB]]]]];
temp={};
If[Last[#]==numberB,AppendTo[temp,#]]&/@newB;
newB=temp;];
(*intersection between the boundaries*)
ptInt={SmallFunctions`IntersectionBoundaryPoints[newB[[1]],newB[[2]]],
SmallFunctions`IntersectionBoundaryPoints[newB[[1]],newB[[3]]],SmallFunctions`IntersectionBoundaryPoints[newB[[3]],newB[[2]]]};
(*fermat point*)
fPt=FermatPointFunctions`GetFermatPoint@Map[First,plateList];
posList=(If[#=={},0,If[SmallFunctions`DistancebtwPoints[fPt,#[[1]]]<=SmallFunctions`DistancebtwPoints[fPt,#[[2]]],1,2]])&/@ptInt;
(*gets the intersection point, it averages themjust incase they are a bit off*)
If[Length[Union[posList]]==1,finalInt=SmallFunctions`MyaveFn[Map[Function[dummy,dummy[[2,dummy[[1]]]]],Transpose[{posList,ptInt}]]],finalInt={};];
(*gets the position of the intersection point that is being replaced*)
bordPos=If[SmallFunctions`DistancebtwPoints[fPt,#[[1]]]<=SmallFunctions`DistancebtwPoints[fPt,#[[2]]],1,2]&/@{newB[[1,2]],newB[[2,2]],newB[[3,2]]};
(*gets the new borders*)
newBB2=Map[Last,Map[Function[dummy,fixedBorderList[[dummy[[1]],dummy[[2]]]]],tripPair]];
anothernewB=GetInterBorders[neT,newBB2];
anB=Map[Last,anothernewB];
If[Length[Union[anB]]==1,anothernewB=anothernewB;,numberB=Last[Last[Sort[Map[Function[dummy,{Count[anB,dummy],dummy}],Union[anB]]]]];
temp={};
If[Last[#]==numberB,AppendTo[temp,#]]&/@anothernewB;
anothernewB=temp;];
(*updates the intersection points*)
upDateBorder=If[finalInt=={},#[[1,2]],ReplacePart[#[[1,2]],finalInt,#[[2]]]]&/@Transpose[{anothernewB, bordPos}];
i=0;
For[i=1, i<=Length[newB],
(*position in the complete border list*)
bd1Pos=Map[Function[dummy,If[Flatten[Position[dummy,newB[[i]]]]=={},{0},Flatten[Position[dummy,newB[[i]]]]]],b2];
(*updates the whole fixed border list*)
newBB2=Map[Function[dummy,If[dummy[[1]]=={0},dummy[[2]],ReplacePoint[dummy[[2]],dummy[[1,1]],upDateBorder[[i]]]]],Transpose[{bd1Pos,newBB2}]];
i++;
];
j=0;
Table[plateList[[j,4]]=newBB2[[j]],{j,1,Length[newBB2]}];
(*updates the whole list*)
(anotherBubList[[#[[1,1]],#[[1,2]]]]=#[[2]])&/@Transpose[{tripPair,plateList}];
];
anotherBubList
]


FindPlateauBoundary[allBubbleList_,precisionFactor_,fixedBub_]:=Module[{newBubbleList,getAllInfo,boundIn,nghPa,pList},
newBubbleList= allBubbleList;
getAllInfo=NeighbourFindingFunctions`GetFinalTripList[allBubbleList,precisionFactor,fixedBub];
(*make pairs from trip list*)
pList={};
If[(Length[#]==2),AppendTo[pList,Sort[#]];,
If[(Length[#]==3),AppendTo[pList,Sort[{#[[1]],#[[2]]}]];
AppendTo[pList,Sort[{#[[1]],#[[3]]}]];
AppendTo[pList,Sort[{#[[3]],#[[2]]}]];
];
]&/@getAllInfo[[4]];
(*boundIn=newBubbleList=GetPlateauBoundary[newBubbleList,Map[First,getAllInfo[[2]]]];*)
boundIn=newBubbleList=GetPlateauBoundary[newBubbleList,Union[pList]];
(*boundIn=newBubbleList=GetPlateauBoundary[newBubbleList,getAllInfo[[4]]];
getAllInfo=NeighbourFindingFunctions`GetFinalTripList[allBubbleList,precisionFactor,fixedBub];*)
(newBubbleList=GetAllBorderIntersection[#,boundIn,newBubbleList])&/@getAllInfo[[4]];
newBubbleList
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
