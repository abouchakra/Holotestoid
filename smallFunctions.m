(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Small Functions


BeginPackage["SmallFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


SmallFunctions::usage="This package is where all the simple repeated function are stored.";


MyaveFn::usage="Finds the average of a List";


FindmidPoint::usage="finds the midpoint between two points";


Drawcirc::usage="draws a list of circles";


Drawcol::usage="draws a list of circles";


Slopedirec::usage="finds the direction of slop";


Sloperatio::usage="finds the ratio given a point";


SlopePerpDirection::usage="finds the perpendicular slope";


IntersectionBetween2Bubbles::usage="Finds intersection between two circles";


IntersectionBetween2lines::usage="Finds intersection between two Lines";


IntersectionBetweenCirclines::usage="Finds intersection between a circle and a Line";


IntersectionBoundaryPoints::usage="Finds intersection between a circle and a Line";


LThanPrec::usage="finds if the value is less than the allowed precision facto";


GreaterThan::usage="finds if the value is greater than the allowed precision facto";


CenterDistance::usage="finds the distance the bubbles will be apart based on their radii law of cosine";


DistancebtwPoints::usage="calculated the distance of a line";


DistFromOnePlate::usage="calculated the distance of all the plates realtive to one";


DirecOfRotation::usage="given two circles it calculates the one which is closer and choses it";


TomakeDistanceExact::usage="this function moves the bubbles to the distance it needs based on the angle,uses a loop to make sure the distance becomes exact or close enough with a an error not larger than the precision Factor";


NumOfPlates::usage="given any number of columns and rows it finds the number of plates in the list";


RowLocation::usage="calculates the rowNumber a plate should be in";


ColumnLocation::usage="calculates the columnNumber a plate should be in";


ListOfPlatePosition::usage="finds plate postion";


PartitionListOfPoints::usage="takes a list and divides it into smaller parts";


LocationOfOnePlate::usage="finds location of one plate";


SBySequence::usage="sorts the plates based on a specified sequence";


SaListBySequence::usage="sorts a neighList trips or pairs of the plates based on a specified sequence";


CheckAngle::usage="makes sure there are no angles greater than 2Pi or less than 0";


mirrorAngle::usage="makes sure there are no angles greater than Pi ";


QuadAngle::usage="returns the quadrant number given an angle";


AngleOfOneSideofThePlate::usage="finds the angle of a slope between two points, goes from 0\[Rule] 2Pi";


AngleAroundThePlate::usage="finds the angle of a slope between two points, goes from 0\[Rule] 2Pi";


CosOfAngleC::usage="finds the angle given 3 sides of a triangle";


AngleCompare::usage="compares two angles to one another and see the difference";


GetTheAnglesForCLosePack::usage="gets the angle for 3 circles in a close pack positions";


AngleFromApex::usage="gets the angle of a bubble relative to the apex and the fixed bubble";


ChooseDirectionForRotationFor3Bub::usage="decides on the direction the 3 bubbles must rotate in";


ChooseDirectionForRotation::usage = "this rotates to the 2 bubble in the pair, it is different from the 3 bub function";


RotationAngleBetweenBubbles::usage="finds the angle of rotation between two bubbles";


RotateCurve::usage="rotate the circle in the correct direction, plist is the points you want to rotale, qlists is around the point you want to rotate";


RotateOneCurve::usage="rotate the circle in the correct direction, plist is the points you want to rotale, qlists is around the point you want to rotate";


RotateAPlateList::usage="applies the rotate curve function to the list of bubbles";


RotateBoundInfo::usage="This still needs works, i need to update the angles too, it is meant to rotate the boudary store list the same way the plate has been rotated";


RotatePlateInfo::usage="rotate the circle in the correct direction, plist is the points you want to rotale, qlists is around the point you want to rotate";


ToRotateColumns::usage="rotates a whole column of bubbles but still needs to rotate the boundary";


RotateAllTHeColumns::usage="rotates all the columns";


OrderThetaQuad::usage = "Quad 1 is bottom left, 4 is top left....there are 3 angles, two intersecting points and the center, goes from 0 to 2Pi,and i need to figure out what quad it is in to make sure the comparison works, quad 2 causes problems so i created a function that determines what to compare";


MatchRange::usage="it is function that checks to see if the bubble position fits within a range with  equal";


MatchRange2::usage="it is function that checks to see if the bubble position fits within a range without  equal";


DrawOneBoundary::usage="draws a list of circles";


DrawAllGrowthLines4OneColumn::usage="draws a list of circles";


DrawCircles4OneColumn::usage="draws a list of circles";


Begin["`Private`"]


Context[zPt];
Context[qPt];


MyaveFn[someList_]:=Total[someList]/Length[someList]


FindmidPoint[twoPoints_]:=1/2*Total[twoPoints]


Drawcirc[circList_]:=
Show[Graphics[{Thickness[0.01],Axes->False, AspectRatio->1,Map[Circle[#[[1]],MyaveFn[#[[2]]]]&,circList, {2}]}]]


Drawcol[circList_]:=
Graphics[{Thickness[0.01],Axes->False, AspectRatio->1,Map[Circle[#[[1]],MyaveFn[#[[2]]]]&,circList, {2}]}]


Slopedirec[pt3_,pt4_]:=(pt3-pt4)


Sloperatio[mPt_]:=0 /; mPt=={0,0}
Sloperatio[mPt_]:= mPt[[2]]/; mPt[[1]]==0
Sloperatio[mPt_]:= mPt[[1]]/; mPt[[2]]==0
Sloperatio[mPt_]:= mPt[[2]]/mPt[[1]]


SlopePerpDirection[pt3_,pt4_]:=# Reverse[pt3-pt4]&/@{{-1,1},{1,-1}};


IntersectionBetween2Bubbles[c1_List,c2_List]:= If[(c1=={})||(c2=={}),{},Solve[{(zPt-(c1[[3,1]]) )^2+ (qPt-c1[[3,2]])^2 ==(c1[[4]])^2,(zPt- (c2[[3,1]]))^2+ (qPt -c2[[3,2]])^2 ==(c2[[4]])^2},
{zPt,qPt}]
]


IntersectionBetween2lines[l1_List,l2_List]:=If[(l1=={})||(l2=={}),{},Solve[{(((l1[[2,2]][[2]])-(l1[[2,1]][[2]]))*(zPt-(l1[[2,1]][[1]])))==(((l1[[2,2]][[1]])-(l1[[2,1]][[1]]))*  (qPt-(l1[[2,1]][[2]]))),(((l2[[2,2]][[2]])-(l2[[2,1]][[2]]))*(zPt-(l2[[2,1]][[1]])))==(((l2[[2,2]][[1]])-(l2[[2,1]][[1]]))*  (qPt-(l2[[2,1]][[2]])))},{zPt,qPt}
]
]


IntersectionBetweenCirclines[l1_List,c2_List]:=If[(l1=={})||(c2=={}),{},
Solve[
{(((l1[[2,2]][[2]])-(l1[[2,1]][[2]]))*(zPt-l1[[2,1]][[1]]))==(((l1[[2,2]][[1]])-(l1[[2,1]][[1]]))*  (qPt-l1[[2,1]][[2]])),(zPt- (c2[[3,1]]))^2+ (qPt -c2[[3,2]])^2 ==(c2[[4]])^2},
{zPt,qPt}
]]


IntersectionBoundaryPoints[pt1_List,pt2_List]:=Module[{interList,solPt,check4Complex,ll},
solPt=Switch[{pt1[[1]],pt2[[1]]},
{1,1},IntersectionBetween2lines[pt1,pt2],
{1,2},IntersectionBetweenCirclines[pt1,pt2],
{2,1},IntersectionBetweenCirclines[pt2,pt1],
{2,2},IntersectionBetween2Bubbles[pt1,pt2]
];
ll={zPt/.#,qPt/.#}&/@solPt;
check4Complex=Flatten@Map[Head,ll,{2}];
If[(Count[check4Complex,Complex])==0,ll,{}]
]


LThanPrec[m1_, m2_, eps_]:=If[Abs[m1-m2]<eps,1,0]


GreaterThan[d1_, d2_, eps_]:=If[Abs[d1-d2]>eps,1,0]


CenterDistance[rA_, rB_, angle_]:= Sqrt[(rA^2)+(rB^2)-(2*rA*rB)*(Cos[angle])]


DistancebtwPoints[data1_List, data2_List]:=Sqrt[Total[(data1-data2)^2]]


DistFromOnePlate[allp_List, p_List] := Map[DistancebtwPoints[#[[1]],p]&,allp,{2}]


DirecOfRotation[circ1_, circlePos_]:=If[DistancebtwPoints[circ1[[1]], circlePos]>DistancebtwPoints[circ1[[2]], circlePos],circ1[[2]],circ1[[1]]]


TomakeDistanceExact[b1_List,b2_List,reqDist_,precisionFactor_,direc_]:=Module[{cenDist,bub,flag,counter,mS,moveM},
mS=(b2[[1]]-b1[[1]]);
bub={b1[[1]],b2[[1]]};
flag=0;
counter=0;
While[((flag==0)&&(counter<2)),
cenDist=DistancebtwPoints@@bub;
moveM=((reqDist-cenDist)*(mS/cenDist));
(*counter\[Equal]0, means it has to do this once, the other times only if it is not exact or close to precision factor*)
If[((reqDist!= cenDist)&&(GreaterThan[reqDist,cenDist,precisionFactor]==1)||(LThanPrec[reqDist,cenDist,precisionFactor]==0))||(counter==0),
Which[direc==1,
bub+{-moveM,+moveM}/2,
direc==2,
bub[[2]]=bub[[2]]+moveM;,
direc==3,
bub+{-moveM,+moveM},
direc==5,
bub[[2]]=bub[[2]]-moveM;,
direc==4,
bub={bub[[2]],bub[[2]]}+({(reqDist-cenDist),(reqDist)}*{-(Reverse[-mS]/cenDist),(Reverse[-mS]/cenDist)});
];
,
flag=1;
];
counter=counter+1;
];
bub
]


NumOfPlates[plateList_List]:=Total[Length/@plateList]


RowLocation[plateNum_,  totalCol_] := Ceiling[plateNum/totalCol]


ColumnLocation[plateNum_,  totalCol_]:= plateNum-( Ceiling[plateNum/totalCol]-1)*totalCol


ListOfPlatePosition[allBubbleList_List]:=Table[{ColumnLocation[pc,Length[allBubbleList]],RowLocation[pc,Length[allBubbleList]]},{pc,1,NumOfPlates[allBubbleList]}]


LocationOfOnePlate[totalCol_,plateNum_]:=Ceiling[{ColumnLocation[plateNum,  totalCol],RowLocation[plateNum, totalCol] }]


PartitionListOfPoints[rpoly1_, parts_]:=Partition[rpoly1,parts,1,{-1,-1}]


numberOfPlatesAddtions[allBubbleList_,plateAdd_]:=Table[(NumOfPlates[allBubbleList]+d),{d,1,plateAdd-NumOfPlates[allBubbleList]}]


SBySequence[sequenceList_,plateNeigh_]:=If[((plateNeigh=={})||(sequenceList=={})),{},Last/@(Sort[{First[Flatten[Position[sequenceList,#]]],#}&/@plateNeigh])]


SaListBySequence[sequenceList_List,plateNeigh_List]:=If[plateNeigh=={},{},Last/@Sort[{First@Flatten@Position[sequenceList,#[[1]]],First@Flatten@Position[sequenceList,#[[2]]],If[Length[#]==3,First@Flatten@Position[sequenceList,#[[3]]],0],#}&/@plateNeigh]]


CheckAngle[angleTheta_]:=N[If[angleTheta>(N[2Pi]),Abs[angleTheta-(2Pi)],
If[angleTheta<(0),(N[2Pi])+angleTheta,angleTheta]]]


mirrorAngle[angleTheta_]:=N[If[angleTheta>(N[Pi]),Abs[angleTheta-(N[2Pi])],
angleTheta]]


QuadAngle[angleTheta_]:=Module[{ang},
ang=CheckAngle[angleTheta];
If[ang<= (N[Pi/2]),3,If[ang<=N[Pi],4,If[ang<=(N[ 3Pi/2]),1,2]]]
]


AngleOfOneSideofThePlate[mPt_]:=0 /; mPt=={0,0}
AngleOfOneSideofThePlate[mPt_]:=N[(ArcTan[mPt[[1]],mPt[[2]]])]


AngleAroundThePlate[mPt_]:=0 /; mPt=={0,0}
AngleAroundThePlate[mPt_]:= N[(ArcTan[mPt[[1]],mPt[[2]]])] /; mPt[[2]]>=0
AngleAroundThePlate[mPt_]:=N[( 2Pi+ArcTan[mPt[[1]],mPt[[2]]])] /; mPt[[2]]<0


CosOfAngleC[rA_,rB_, rC_]:= N[ArcCos[((rA^2 )+(rB^2 )-(rC^2 ))/(2*rA*rB)]]


GetTheAnglesForCLosePack[radii_,dt_]:=CosOfAngleC[dt+#[[1]],#[[2]]+#[[1]],dt+#[[2]]]&/@{{radii[[1]],radii[[2]]},{radii[[1]],radii[[3]]}}


AngleCompare[mid_, perP_, bubP_]:=Module[{},
Abs[ AngleAroundThePlate[mid-perP]-AngleAroundThePlate[mid-bubP]]
]


AngleFromApex[apex_,g1_,bubbLeList_]:=Module[{angle},
angle=AngleAroundThePlate[(#[[1]]-apex)]&/@{g1,bubbLeList[[2]],bubbLeList[[3]]};
(*this is not totally figured out, butit decides if the bubbles that havent been move take the new angle or the old list angle*)
If[Abs[#[[1]]-#[[2]]]==Abs[#[[1]]-#[[3]]],0,If[Abs[#[[1]]-#[[2]]]>Abs[#[[1]]-#[[3]]],3,2]]&@angle
]


ChooseDirectionForRotationFor3Bub[anglesList_List, centerList_List]:=Module[{angLoc,quadPos},angLoc= AngleAroundThePlate[(#-centerList[[1]])]&/@{centerList[[2]],centerList[[3]]};
quadPos=Map[QuadAngle,angLoc];
(*if quad 2 bottom right and 3 top right, the direction changes, otherwise it work from smalled to largest angles*)
If[MemberQ[{{2,3},{3,2}},quadPos]==True,
(*this is neccessary because if comparing the quads 0-90 and 270-360, they dont overlap so they need a different comparion*)
If[quadPos=={3,2},{-1,1}*anglesList, {1,-1}*anglesList]
,
(*quads 1 and 3 are across from one another, this function needs to distinguish which side the triange is on, so it looks for the smallest angle*)
If[MemberQ[{{1,3},{3,1}},quadPos]==True,
theta=N[Abs[angLoc[[1]]-angLoc[[2]]]];
If[quadPos=={1,3},If[theta<N[(2Pi -theta)],{-1,1}*anglesList, {1,-1}*anglesList],If[theta>N[(2Pi -theta)],{-1,1}*anglesList, {1,-1}*anglesList]],
If[angLoc[[1]]>angLoc[[2]],{-1,1}*anglesList, {1,-1}*anglesList]
]
]
]


ChooseDirectionForRotation[oneangle_, centerList_List]:=Module[{angLoc,quadPos,theta},
angLoc= AngleAroundThePlate[(#-centerList[[1]])]&/@{centerList[[2]],centerList[[3]]};
quadPos=Map[QuadAngle,angLoc];
(*if quad 2 bottom right and 3 top right, the direction changes, otherwise it work from smalled to largest angles*)
If[MemberQ[{{2,3},{3,2}},quadPos]==True,
If[quadPos=={3,2},1*oneangle, -1*oneangle]
,
If[MemberQ[{{1,3},{3,1}},quadPos]==True,
theta=Abs[angLoc[[1]]-angLoc[[2]]];
If[quadPos=={1,3},If[theta<(2Pi -theta),1*oneangle, -1*oneangle],If[theta>(2Pi -theta),1*oneangle, -1*oneangle]],
If[angLoc[[1]]>angLoc[[2]],1*oneangle, -1*oneangle]
]
]
]


RotationAngleBetweenBubbles[pairBubbles_List, fixeBubble_List]:=Module[{anglesL,newPt},
(*this function takes a new position and compares it to the old and then determins the angle difference it needs to move back to the old position*)
anglesL= AngleAroundThePlate[(#-fixeBubble[[1]])]&/@{pairBubbles[[1,1]],pairBubbles[[2,1]]};
N[(anglesL[[2]]-anglesL[[1]])]
]


(*this was used but i changed it to the previous funvtion*)
RotationAngleBetweenBubbles2[pairBubbles_List, fixeBubble_List]:=Module[{anglesL,newPt},
anglesL=CosOfAngleC[(DistancebtwPoints[fixeBubble[[1]],#[[1,1]]]),(DistancebtwPoints[fixeBubble[[1]],#[[2,1]]]),DistancebtwPoints[#[[1,1]],#[[2,1]]]]&@pairBubbles;
ChooseDirectionForRotation[anglesL,{ fixeBubble[[1]],pairBubbles[[1,1]],pairBubbles[[2,1]]}]
]


RotateCurve[p_List, theta_,q_List] := 
Table[
q+{
{Cos[theta],Sin[theta]} . (p[[i]]-q), 
{-Sin[theta], Cos[theta]} .( p[[i]]-q)
}, 
{i, Length[p]}
]


RotateOneCurve[p_List, theta_,q_List] := q+{{Cos[theta],Sin[theta]} . (p-q), {-Sin[theta], Cos[theta]} .( p-q)}


RotateAPlateList[p_List, theta_,q_List]:=Module[{onePlate},
onePlate=p;
onePlate[[1]]=RotateOneCurve[onePlate[[1]], theta,q] ;
onePlate
]


RotateBoundInfo[boundInfo_List,theta_,apex_]:=Module[{ni},
ni=boundInfo;
If[ni[[1]]==1,
ni[[2]]=RotateOneCurve[#, theta,apex]&/@ni[[2]];
ni[[4]]=RotateOneCurve[ni[[4]], theta,apex];
,
ni[[2]]=RotateOneCurve[#, theta,apex]&/@ni[[2]];
ni[[3]]=RotateOneCurve[ni[[3]], theta,apex];
ni[[6]]=RotateOneCurve[ni[[6]], theta,apex];
];
ni
]


RotatePlateInfo[plateList_List, theta_,apex_] :=Module[{newList},
newList=plateList;
newList[[1]]=RotateOneCurve[newList[[1]], theta,apex] ;
newList[[3]]=RotateBoundInfo[#, theta,apex]&/@newList[[3]];
newList
]


ToRotateColumns[colPlates_List,theta_,apex_]:=RotatePlateInfo[#, theta,apex]&/@colPlates 


RotateAllTHeColumns[allBubbleList_List,newList_List,newPlate_List]:=Module[{lastPlate,angleOfRot,rotationPlate},
lastPlate={1,1};
angleOfRot=RotationAngleBetweenBubbles[{newList[[lastPlate[[1]],lastPlate[[2]]]],allBubbleList[[lastPlate[[1]],lastPlate[[2]]]]}, newList[[newPlate[[1]],newPlate[[2]]]]];
rotationPlate= newList[[newPlate[[1]],newPlate[[2]]]];
Map[
RotateAPlateList[#,angleOfRot,(rotationPlate[[1]])]&,
newList,{2}]
]



(*so the quads are bottom left 1, bottom right 2 top right 3 and top left 4*)
(*this functions decides which quad the angles are in and since 2 and 3 cause problems less than 90 greater than 270 to 360 no direct overlap, so it makes sure it knows that by setting it as 2, this will be used for matchrange*)
(******the sort function would not sort {1.5676547341413067`,1.5739379194484864`,\[Pi]/2} or {-1+(499 \[Pi])/1000,1+(501 \[Pi])/1000,\[Pi]/2} properly, so i had to get the N function to do it right*)
OrderThetaQuad[thetaQuad_]:=Module[{theta},
theta=Sort[N[thetaQuad[[1]]]];
If[(MemberQ[thetaQuad[[2]],2]==True),
Which[
(Sort[thetaQuad[[2]]]=={1,2,3}),{2,First[theta],theta[[2]]},
(MemberQ[thetaQuad[[2]],1]==True),{1,First[theta],Last[theta]},
(Sort[thetaQuad[[2]]]=={2,2,3}),{2,First[theta],theta[[2]]},
(MemberQ[{{2,3,3},{2,3,4}},Sort[thetaQuad[[2]]]]==True),{2,theta[[2]],Last[theta]},
(MemberQ[{{2,2,4},{2,4,4}},Sort[thetaQuad[[2]]]]==True),{1,First[theta],Last[theta]},
(MemberQ[{{2,3}},Sort[thetaQuad[[2]]]]==True),{2,First[theta],Last[theta]},
(Union[thetaQuad[[2]]]=={2}),{1,First[theta],Last[theta]}
]
,
{1,First[theta],Last[theta]}
]

]


(*this tests to see if and angle fists between two other angles, quad 2 and 3 \[Equal]2will have different condiotions since it will be less than 90 and greater than 270*)
MatchRange[thetaRange_, angleTheta_]:=
Which[
(thetaRange[[1]]==1),
If[((thetaRange[[2]]<=N[angleTheta])&&(thetaRange[[3]]>=N[angleTheta])),1,0]
,
(thetaRange[[1]]==2),
If[((thetaRange[[3]]<=N[angleTheta])||(thetaRange[[2]]>=N[angleTheta])),1,0]
]


(*this tests to see if and angle fists between two other angles, quad 2 and 3 \[Equal]2will have different condiotions since it will be less than 90 and greater than 270*)
MatchRange2[thetaRange_, angleTheta_]:=
Which[
(thetaRange[[1]]==1),
If[((thetaRange[[2]]<N[angleTheta])&&(thetaRange[[3]]>N[angleTheta])),1,0]
,
(thetaRange[[1]]==2),
If[((thetaRange[[3]]<N[angleTheta])||(thetaRange[[2]]>N[angleTheta])),1,0]
]


GetBoundForATimePeriod[allPlateList_,plateNum_]:=Module[{boundaries,bdPos},
boundaries=Flatten[Flatten[Last/@#,1]&/@allPlateList,1];
bdPos=First/@Position[boundaries,plateNum];
boundaries[[#]]&/@bdPos
]


DrawAPlateCircle[onebubble_,rl_:1]:=Circle[onebubble[[1]],MyaveFn[onebubble[[2]]]] /;rl==1
(*for now this is ok, but i would prefer to draw half with one radius and the other with another radius...may not be neccessary, but id like to see what it looks like or draw all the growth lines for one plate..i think that is important to do*)
DrawAPlateCircle[onebubble_,rl_:1]:=Circle[onebubble[[1]],onebubble[[2]][[rl]]]/; rl==2


DrawCircles4OneColumn[oneColumn_]:=If[oneColumn=={},Line[{{0,0},{0,0}}],Map[DrawAPlateCircle,oneColumn]]


DrawOneBoundary[bdy_]:=If[bdy=={},Line[{{0,0},{0,0}}],If[bdy[[1]]==1,Line[bdy[[2]]],Circle[bdy[[3]],bdy[[4]],bdy[[5]]]]]


DrawAllGrowthLines4OneColumn[oneColumn_]:=DrawOneBoundary/@#[[4]]&/@oneColumn


DrawOneTimeGrowthLines4Col[oneColumn_]:=Module[{temp,newB,finalGraphics},
finalGraphics={};
Map[Function[dummy,
If[Length@Union[Last/@dummy[[4]]]==1,newB=dummy[[4]];,
temp={};
If[Last[#]==Max@Union[Last/@dummy[[4]]],AppendTo[temp,#]]&/@dummy[[4]];
newB=temp;];
AppendTo[finalGraphics,DrawOneBoundary/@newB];]
,
oneColumn];
finalGraphics
]


(*drawType, 1=just the circle no boundary for columns, 2=all circle and all current boundary,3 one circle and all its boundaries, 4, all circles and all boundary,5 currentBoundaries no circles*)
DrawAllPlates[allPlatesList_,drT_,p_:{1,0,1},opt_:1]:=Module[{allCurrentPlateBoundary,g,newBubbleList,plateNum},
newBubbleList=allPlatesList;
Which[
drT==3,plateNum=NumOfPlates[newBubbleList];,
((drT==2)||(drT==5)),
If[Length[newBubbleList]>=4,
plateNum=NumOfPlates[Take[newBubbleList,Length[newBubbleList]-3]];
allCurrentPlateBoundary=GetBoundForATimePeriod[newBubbleList,plateNum];
plateNum=NumOfPlates[Take[newBubbleList,-3]];
allCurrentPlateBoundary=Join[allCurrentPlateBoundary,GetBoundForATimePeriod[Take[newBubbleList,-3],plateNum]];
,
plateNum=NumOfPlates[newBubbleList];
allCurrentPlateBoundary=GetBoundForATimePeriod[newBubbleList,plateNum];
];
];
g=Switch[drT,1,Graphics[{RGBColor[p[[1]],p[[2]],p[[3]]],Map[DrawCircles4OneColumn,newBubbleList]}],2,Graphics[{RGBColor[p[[1]],p[[2]],p[[3]]],Map[DrawCircles4OneColumn,newBubbleList],Map[DrawOneBoundary,allCurrentPlateBoundary]}],3,Graphics[{RGBColor[p[[1]],p[[2]],p[[3]]],DrawAPlateCircle[{newBubbleList[[1]],newBubbleList[[2]]},opt],Map[DrawOneBoundary,newBubbleList[[3]]]}],4,Graphics[{RGBColor[p[[1]],p[[2]],p[[3]]],Map[DrawCircles4OneColumn,newBubbleList],Map[DrawAllGrowthLines4OneColumn,newBubbleList]}],5,Graphics[{RGBColor[p[[1]],p[[2]],p[[3]]],Map[DrawOneBoundary,allCurrentPlateBoundary]}]];

g
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
