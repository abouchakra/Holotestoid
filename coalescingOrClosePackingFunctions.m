(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Analogy of Coalescing Or Close Packing Soap Bubbles:


Needs["SmallFunctions`"]


Needs["FermatPointFunctions`"]


Needs["DescartesFunctions`"]


Needs["MovingFunctions`"]


Needs["NeighbourFindingFunctions`"]


BeginPackage["CoalescingOrClosePackingFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


CoalescingOrClosePackingFunctions::usage="1)Plate Interaction:Plateau's Law and Laplace-Young Eqn for Coalescing Bubbles.\[IndentingNewLine]2)Plate Gaping:Descartes Theorem and Fermat for Close Packing Bubbles.";


Move2Bubbles::usage="Coalescing Or Close Packing 2 Bubbles";


ThreemeetPlateauOrFermat::usage="Coalescing Or Close Packing Soap Bubbles, based on plateau or fermat and descartes";


Move3Bubbles::usage="Coalescing Or Close Packing 3 Bubbles";


CheckForSingleBubbleOverlapsRound2::usage="checks for interacting wrong overlaps";


FnthatCPorCoalesce::usage="this function decides if it is a pair then it will close pack based on plateau, or trip based on fermat and descartes, if neither it just returns the newList";


InteractTrips::usage="this interacts all the trips available in a column";


CoalesceORclosePackBubbles::usage="this is the main function that finds the neighbours, tripsorparis and then interacts the columns";


Begin["`Private`"]


Move2Bubbles[bPair_, oldList_,allBubbleList_,fixedList_,oldFixed_,precisionFactor_, direc_,cpOPT_]:=Module[{pr,newBubList,temp,b01,np,reqDist,angleRt,pbubbles,checkBub,fNum,apt},
(*original list or trips or bubbles*)
pr=bPair;
(*this checks how many are already fixed*)
checkBub=If[MemberQ[fixedList,#],{0,#},{1,#}]&/@pr;
fNum=Count[First/@checkBub,0];
Which[fNum==0,apt=0;,
fNum==1,apt=1;checkBub=If[MemberQ[oldFixed,#]==True,{-1,#},If[MemberQ[fixedList,#]==True,{0,#},{1,#}]]&/@pr;
pr=Last/@Sort[checkBub];
];
If[fNum==2,allBubbleList,
(*get the pair from the original list*)
b01={oldList[[pr[[1,1]],pr[[1,2]]]],oldList[[pr[[2,1]],pr[[2,2]]]]};
(*gets pair from new list*)
np={allBubbleList[[pr[[1,1]],pr[[1,2]]]],allBubbleList[[pr[[2,1]],pr[[2,2]]]]};
(*np[[1]] is usually the fixed bubble, if it was moved then it moves the pair relative to it *)
np[[2,1]]=b01[[2,1]]+(np[[1,1]]-b01[[1,1]]);
(*averages the radii*)(*later i would like to implement not just average radii*)
pbubbles={{np[[1,1]],SmallFunctions`MyaveFn[np[[1,2]]]},{np[[2,1]],SmallFunctions`MyaveFn[np[[2,2]]]}};
If[cpOPT==0,
(*when interaction occures this moves the bubbles the proper distance towards each other based on plateau's law, where the angles between the radi must make 60 degrees*)
reqDist = SmallFunctions`CenterDistance[pbubbles[[1,2]],pbubbles[[2,2]],Pi*60/180];,
(* close pack 2 bubbles, because it works on the same principles up with a different required Distance*)
reqDist = pbubbles[[1,2]]+pbubbles[[2,2]];
];
temp=SmallFunctions`TomakeDistanceExact[pbubbles[[1]],pbubbles[[2]],reqDist,precisionFactor,direc];

np[[1,1]]=temp[[1]];np[[2,1]]=temp[[2]];
newBubList=allBubbleList;
newBubList[[pr[[2,1]],pr[[2,2]]]]=np[[2]];
newBubList
]
]


ThreemeetPlateauOrFermat[bubbleList_,originalCen_,precisionFactor_,apt_,cpOpt_]:=Module[{newBubbleList,centList,radii,fp,dt,anglesL , anglesList, CpOrPlateauDist,pTrot},
centList= Map[First,bubbleList];
radii= SmallFunctions`MyaveFn[#[[2]]]&/@bubbleList;
(*apt \[Equal]1 means that there are 2 bubbles fixed, apt \[Equal]0 mean 2 bubbles are definitly Not fixed, depending on closepacking or coalescing determines the distance. coalescing uses the function centerdistance to calculated the plateau distance between two bubble, clopsepacking needs to have ra + rb distance unless they are fixed*)
Switch[{apt,cpOpt},
{0,0},CpOrPlateauDist={SmallFunctions`CenterDistance[#[[1]],#[[3]],Pi*60/180],(SmallFunctions`CenterDistance[#[[1]],#[[2]],Pi*60/180]), SmallFunctions`CenterDistance[#[[2]],#[[3]],Pi*60/180]};,
{1,0},
CpOrPlateauDist={SmallFunctions`CenterDistance[#[[1]],#[[3]],Pi*60/180],SmallFunctions`DistancebtwPoints[centList[[1]],centList[[2]]],SmallFunctions`CenterDistance[#[[2]],#[[3]],Pi*60/180]};,
{1,1},
CpOrPlateauDist={(#[[1]]+#[[3]]),SmallFunctions`DistancebtwPoints[centList[[1]],centList[[2]]],(#[[2]]+#[[3]])};,
{0,1},
CpOrPlateauDist={(#[[1]]+#[[3]]),(#[[1]]+#[[2]]),(#[[2]]+#[[3]])};
]&@radii;
If[{apt,cpOpt}=={0,1},
(*Fp radius based on descartes theorem*)
dt=DescartesFunctions`DescartesTheorem @@radii;
(*Fermat Point*)
fp =FermatPointFunctions`GetFermatPoint[centList];
fp=MovingFunctions`MoveNewBubble[fp,dt,bubbleList,precisionFactor];
(*gets the angles of the close-packing triangle between the main bubble and the other sides*)
anglesL=SmallFunctions`GetTheAnglesForCLosePack[radii,dt];
(*decides whether fp should move left or right to match the previous bubbles positions, so it chooses based on the angles the bubbles make around the fixed bubbles and determines how much it will rotate right and hoe much left to make the closepacking triangle*)
anglesList=SmallFunctions`ChooseDirectionForRotationFor3Bub[anglesL,centList];
pTrot=fp;
,
(*finds the angle of the triangle*)
anglesL=SmallFunctions`CosOfAngleC[CpOrPlateauDist[[1]],CpOrPlateauDist[[2]],CpOrPlateauDist[[3]]];
(*chooses a direction to rotate the bubbles*)
anglesList=SmallFunctions`ChooseDirectionForRotationFor3Bub[{anglesL,anglesL},originalCen];
anglesList={0,anglesList[[2]]};
(*adjusts position of second bubbles*)
If[apt==0,
centList[[2]]=SmallFunctions`TomakeDistanceExact[{centList[[2]],radii[[2]]},{centList[[3]],radii[[3]]},
(CpOrPlateauDist[[3]]),precisionFactor,2][[1]];];
pTrot=centList[[2]];
];
(*Creates a new list with the proper angle positions*)
centList=Join[{centList[[1]]},SmallFunctions`RotateOneCurve[pTrot,#,centList[[1]]]&/@anglesList];
(*now it needs to move them to their proper distance not just slope/angle, so it finds the new anglePos the bubble make to the fixed bubble and then move them to the proper distance away*)
newBubbleList=bubbleList;
(*if 2nd bub is not fixed the first step is to move it away from bub one*)
If[apt==0,
newBubbleList[[2,1]]=SmallFunctions`TomakeDistanceExact[{centList[[1]],radii[[1]]},{centList[[2]],radii[[2]]},
(CpOrPlateauDist[[2]]),precisionFactor,2][[2]];
];
(*if second bub is fixed, first bub 3 moved away from one, then from 2 , and finally repeats againfrom bub 1*)
newBubbleList[[3,1]]=SmallFunctions`TomakeDistanceExact[{centList[[1]],radii[[1]]},{centList[[3]],radii[[3]]},
(CpOrPlateauDist[[1]]),precisionFactor,2][[2]];
newBubbleList[[3,1]]=SmallFunctions`TomakeDistanceExact[{newBubbleList[[2,1]],radii[[2]]},{newBubbleList[[3,1]],radii[[3]]},
(CpOrPlateauDist[[3]]),precisionFactor,2][[2]];
newBubbleList[[3,1]]=SmallFunctions`TomakeDistanceExact[{centList[[1]],radii[[1]]},{newBubbleList[[3,1]],radii[[3]]},
(CpOrPlateauDist[[1]]),precisionFactor,2][[2]];
newBubbleList
]


Move3Bubbles[ortrip_, oldList_,allBubbleList_,sequenceList_,precisionFactor_,cpOpt_,fixedBubList_]:=Module[{newBubbleList,checkBub,fixedBub,bubList,oldbub,np,angleRt,cp,apt,trip,fNum},
apt=0;trip=ortrip;fNum=0;
(*this step checks for fixed bubbles*)
checkBub=If[MemberQ[fixedBubList,#],{0,#},{1,#}]&/@trip;
fNum=Count[Map[First,checkBub],0];
Which[
fNum==1,apt=0;
trip=Map[Last,Sort[checkBub]];trip=Join[{trip[[1]]},SmallFunctions`SBySequence[sequenceList,Take[trip,-(Length[trip]-1)]]];,
fNum==2,apt=1;
trip=Map[Last,Sort[checkBub]];
trip=Join[SmallFunctions`SBySequence[sequenceList,Take[trip,(Length[trip]-1)]],{Last[trip]}];
];
newBubbleList=allBubbleList;
If[(fNum==3),
(*if there is no interaction, then it returns the list and 0 indicating no interaction*)
newBubbleList={0,newBubbleList};,

(*oldbub and bublist store the 3 bubbles from the original list*)
oldbub=bubList={oldList[[trip[[1,1]],trip[[1,2]]]],oldList[[trip[[2,1]],trip[[2,2]]]],oldList[[trip[[3,1]],trip[[3,2]]]]};
(* the first bub is always fixed*)
fixedBub=newBubbleList[[trip[[1,1]],trip[[1,2]]]];
(*apt\[Equal]0 means 2 are NOt fixed, apt\[Equal]1 means 2 are fixed*)
Which[apt==0,
(*this adjust the location relative to the new position of the fixed bub*)
bubList[[2,1]]=bubList[[2,1]]+(fixedBub[[1]]-oldbub[[1,1]]);
bubList[[3,1]]=bubList[[3,1]]+(fixedBub[[1]]-oldbub[[1,1]]);
bubList[[1,1]]=fixedBub[[1]];,
(apt==1),
(*shifts the old list accordingly so that the bubles are still the same relative to one another, this is important for angles*)
bubList[[2]]=newBubbleList[[trip[[2,1]],trip[[2,2]]]];
(*rotation to match new angle*)
angleRt= {SmallFunctions`AngleAroundThePlate[(bubList[[2,1]]-fixedBub[[1]])],SmallFunctions`AngleAroundThePlate[(oldbub[[2,1]]-oldbub[[1,1]])]};
angleRt=(angleRt[[2]]-angleRt[[1]]);
bubList[[3,1]]=
SmallFunctions`RotateOneCurve[bubList[[3,1]],angleRt, oldbub[[1,1]]];
(*movement*)
bubList[[3,1]]=bubList[[3,1]]+(fixedBub[[1]]-oldbub[[1,1]]);
bubList[[1]]=newBubbleList[[trip[[1,1]],trip[[1,2]]]];
];

If[((fNum==2)&&(SmallFunctions`DistancebtwPoints[bubList[[1,1]],bubList[[2,1]]]>=  Total[Flatten[SmallFunctions`MyaveFn[#[[2]]]&/@bubList*{1,1,2}]])),
(*if the triangle doesnt make sense then the program doesnt interact or cp the bubbles*)
newBubbleList[[trip[[3,1]],trip[[3,2]]]][[1]]=bubList[[3,1]];
newBubbleList={1,newBubbleList};
,
np=ThreemeetPlateauOrFermat[bubList,#,precisionFactor,apt,cpOpt]&@ Map[First,oldbub];
(*if the bubbles have already been close packed/coalessed in another, apt \[Equal]1, turn then it makes sure that it rotates so that they match*)
(*Print[SmallFunctions`Drawcirc[{np}]];*)
If[(apt==0),
If[((#[[2]]==#[[3]]&&#[[2]]==#[[1]])&@(SmallFunctions`MyaveFn[#[[2]]]&/@np)),
angleRt=0;
,
(*i put a negative because it appeared to rotate the wrong way*)

angleRt=-1*SmallFunctions`RotationAngleBetweenBubbles[{{SmallFunctions`FindmidPoint[{np[[2,1]],np[[3,1]]}]},{SmallFunctions`FindmidPoint[{bubList[[2,1]],bubList[[3,1]]}]}},bubList[[1]]];

];
,angleRt=0;
];
If[angleRt==0,cp={np[[2,1]],np[[3,1]]};,
(*rotates only if angle doesnt equal to 0*)
cp=
Map[Function[dummy,
SmallFunctions`RotateOneCurve[dummy,angleRt, fixedBub[[1]]]],
{np[[2,1]],np[[3,1]]}]];
np[[2,1]]=cp[[1]];np[[3,1]]=cp[[2]];
(*Print[SmallFunctions`Drawcirc[{np}]];*)
(*updates list*)
(newBubbleList[[#[[1,1]],#[[1,2]]]][[1]]=#[[2]])&/@Transpose[{trip,{np[[1,1]],cp[[1]],cp[[2]]}}];
newBubbleList={1,newBubbleList};
];
];
newBubbleList
]


FnthatCPorCoalesce[bubSet_,allBubbleList_,newList_, triplettes_,sequenceList_,precisionFactor_,fixedBub_,origFixed_,cpOpt_]:=If[Length[bubSet]==3,Move3Bubbles[bubSet,allBubbleList,newList,sequenceList,precisionFactor,cpOpt,fixedBub],
If[(Length[bubSet]==2)(*&&((Count[NeighbourFindingFunctions`CheckForWrongPairs[bubSet, triplettes],{3,True}])\[Equal]0)*),
{1,Move2Bubbles[bubSet,allBubbleList,newList,fixedBub,origFixed,precisionFactor,2,cpOpt]}
,
{0,newList}
]
]


CheckForCPSingleBubbleOverlaps[currentList_,allBubbleList_,sequenceList_,triplettes_,tNum_,precisionFactor_,fixedBub_,oldFixedList_,cpOpt_]:=Module[{trip, apt,fNum,newT,fixedBubList,newneigh,allNeigh,tempNeigh,trialc,temp,checkBub, newfixedList,tempTrip,u,counter,tempNewT},
trip=triplettes[[tNum]];
(*this checks to see if all the bubbles are fixed*)
trip=Complement[triplettes[[tNum]],fixedBub];
If[(trip=={}),{0,currentList,{}},
trip=SmallFunctions`SBySequence[triplettes[[tNum]],trip];
temp=currentList;fixedBubList=fixedBub;tempTrip=newT={};trialc=0;
For[u=1, u<=Length[trip],
If[MemberQ[fixedBubList,trip[[u]]]==True, u++;counter=0;newT={};trialc=0;,
tempNeigh=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[temp,temp[[trip[[u,1]],trip[[u,2]]]],precisionFactor,If[cpOpt==1,2,6]];
allNeigh=newneigh=Intersection[tempNeigh[[2]],fixedBubList];
If[newneigh=={},
u++;newT={};counter=0;
,
tempNeigh=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[temp,temp[[trip[[u,1]],trip[[u,2]]]],precisionFactor,If[cpOpt==1,1,1]];
newneigh=SmallFunctions`SBySequence[tempNeigh[[2]],Intersection[tempNeigh[[2]],fixedBubList]];
newfixedList=Complement[fixedBubList, newneigh];
(*first we look in trips*)
If[Length[newneigh]>1,AppendTo[newT,SmallFunctions`SBySequence[sequenceList,{newneigh[[1]],newneigh[[2]],trip[[u]]}]]];

If[(MemberQ[newT, #]==False)&&(#!= triplettes[[tNum]]),
If[
((((Length[Intersection[#,newneigh]]==1 )&& (Length[Intersection[#, newfixedList]]==1))||(Length[Intersection[#,newneigh]]==2 ))&&(Length[Intersection[#,{trip[[u]]}]]==1) ), AppendTo[newT,#];];
]&/@ triplettes;
newT=Complement[newT,triplettes[[tNum]]];
(*then it gets the pairs*)
Map[Function[dum2,Map[Function[dum,If[dum2==dum,newT=Join[newT,SmallFunctions`SBySequence[sequenceList,{{dum2,trip[[u]]}}]],
tempNewT=SmallFunctions`SBySequence[sequenceList,{{dum2,dum,trip[[u]]}}];
If[MemberQ[newT, tempNewT]==False,
newT=Join[newT,tempNewT],newT=Join[newT,SmallFunctions`SBySequence[sequenceList,{{dum2,trip[[u]]}}]]];];],newneigh]],allNeigh];
(*then it interacts*)
counter=1;
While[(allNeigh != {})&&( counter<=Length[newT]),
If[(Length[newT[[counter]]]==2&&((Count[NeighbourFindingFunctions`CheckForWrongPairs[newT[[counter]],newT],{3,True}])==0))||Length[newT[[counter]]]==3,
temp=FnthatCPorCoalesce[newT[[counter]],allBubbleList,temp, triplettes,sequenceList,precisionFactor,fixedBubList,oldFixedList,cpOpt];
temp=temp[[2]];
];
tempNeigh=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[temp,temp[[trip[[u,1]],trip[[u,2]]]],precisionFactor,If[cpOpt==1,2,6]];
allNeigh=Intersection[tempNeigh[[2]],fixedBubList];
tempTrip=newT[[counter]];
counter++;
];
trialc++;
newT={};
If[(tempNeigh == {}),fixedBubList=Union[Join[fixedBubList,tempTrip]];u++;,counter=0;newT={};];
(*still needs some thinking, may not need to loop as much*)
If[(trialc>10),u++;counter=0;newT={};];
];
];
];
{1,temp,{}}
]
]


InteractTrips[sequenceList_, tripList_,allBubbleList_,precisionFactor_,fixedBub_,cpOpt_]:=Module[{newList,triplettes,t,temp,flag,fixedBubList,finalTrips,newallSeqIn,ngl,compList,tempFlag},
newList=allBubbleList;
triplettes=tripList;
(*this loops until the bubbles have been checked at least 1 once for overlap*)
temp={1,newList};
t=0;
fixedBubList=fixedBub;
compList={};
For[t=1,t<=Length[triplettes],
(*Print[compList];
Print[Take[triplettes,t-1]];
Print[Complement[Take[triplettes,t-1],compList]];*)
fixedBubList=If[(t)==1,fixedBubList,
Union[Join[fixedBubList,Flatten[Complement[Take[triplettes,t-1],compList],1]]]];(*Union[Join[fixedBubList,Flatten[Take[triplettes,t-1],1]]]];*)
(*fixedBubList=SmallFunctions`SBySequence[sequenceList,fixedBubList];*)
flag=1;(*if flag \[Equal]0 then we can drop t from triplets and t=t-1*)
(*Print[SmallFunctions`Drawcirc[temp[[2]]]];*)
temp=FnthatCPorCoalesce[triplettes[[t]],allBubbleList,temp[[2]], triplettes,sequenceList,precisionFactor,fixedBubList,fixedBub,cpOpt];

tempFlag=temp[[1]];
If[cpOpt==1||cpOpt==1,
temp=CheckForCPSingleBubbleOverlaps[temp[[2]],allBubbleList,sequenceList,triplettes,t,precisionFactor,fixedBubList,fixedBub,cpOpt];
If[(tempFlag==0)&&(temp[[1]]==0),compList=AppendTo[compList,triplettes[[t]]]];
];
t=t+1;
];
temp[[2]]
]


CoalesceORclosePackBubbles[allBubbleList_,precisionFactor_,fixedBub_,cpOpt_]:=Module[{newBubbleList,getAllInfo},
newBubbleList= allBubbleList;
If[SmallFunctions`NumOfPlates[newBubbleList]==0,newBubbleList,
If[cpOpt==2,
getAllInfo=NeighbourFindingFunctions`GetFinalTripList2[newBubbleList,precisionFactor,fixedBub,10];
newBubbleList=InteractTrips[getAllInfo[[3]],getAllInfo[[4]],newBubbleList,precisionFactor,fixedBub,1];
,
getAllInfo=NeighbourFindingFunctions`GetFinalTripList[allBubbleList,precisionFactor,fixedBub];
newBubbleList=InteractTrips[getAllInfo[[3]],getAllInfo[[4]],newBubbleList,precisionFactor,fixedBub,cpOpt];
];
newBubbleList
]
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
