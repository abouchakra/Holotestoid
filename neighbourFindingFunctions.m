(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Find Neighbouring Plates 


Needs["SmallFunctions`"]


BeginPackage["NeighbourFindingFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


NeighbourFindingFunctions::usage="This package is where all the neighbour calculating functions are stored.";


SumRadii::usage="calculated the distance plates need to be realtive to one";


FindCloseNeighbours::usage="finds the close neighbours that fit a distance criteria";


FindExactDistanceNeighbours::usage="this criteria has to be exact no between valuies";


OverlappingNeighbours::usage="checks the bubbles that are wrongly overlapped";


NeighBourFinderBasedOnDistance::usage="this function will find neighbours based on distance ";


UpdateNeighList::usage="updates the neighlist";


GetClosestBub::usage="finds the closest neighbouring plate, doesnt matter if it is touching the plate";


GetAllcloseNeigh::usage="gets the close neigh for the whole column";


PairNeigh::usage="makes pairs for a bubble with its neighbours {1, {2,3}}->(1,2),(1,3)";


GetAllPairs::usage="gets all the pairs for the whole columns";


GetNeighInt::usage="for each pair it finds the neighbours they share ";


GetNeighPairsInfoList::usage="returns alist where it finds the shared bubbles ex {1,2}->share{3}";


CheckForWrongPairs::usage ="this function makes sure that if there is a pair it is not found within a different trip set";


CheckForWrongTrips::usage="this function makes sure that if there is a trip for each bubble ";


PerpenSortInfoList::usage="sorts the neighbours based on the pairs, each pair can only interact or closepack with one bubble on either side, so the makes sure that there are only 2 bubbles and one from each sid are creating a triplet and avoind wrong triplets";


SeqSortAllInfoList::usage="sorts the neighbours based on the pairs";


GetTripsFromAllSeqInfo::usage="gets all possible trips";


TripNeighbourFinder3ofakind::usage="this function removes trips that are not shared by all three bubbles, or pairs that are not shared by both bubbles";


TripNeighbourFinder2::usage="this function removes trips that are not shared by all three bubbles, or pairs that are not shared by both bubbles";


GetAveDistance::usage="gets the sequence List for the whole column based on distance";


GetASequenceForCol::usage="gets the sequence List for the whole column, this is done by distance from the starting bubble and angle, the angle chosen is based on the angle of the farthest bubble to the starting one, so example if we start with angle Pi/2, then all the bubbles the match Pi/2 will be chosen then sorted by distance, the function then increments the range (pi/2+ Range) to (pi/2-range). The increment can be any value, currently the function uses PI/10000";


SecondLevelNeighbourSorter::usage="gets the trip, sequence list and neighbours list";


LoopThroughThetas::usage="gets the trip, sequence list and neighbours list";


NeighbourAngle::usage="gets the trip, sequence list and neighbours list";


allNeighboursAround::usage="gets the trip, sequence list and neighbours list";


GetallNeighboursAround::usage="gets the trip, sequence list and neighbours list";


GetFinalTripList2::usage="gets the trip, sequence list and neighbours list";


GetFinalTripList::usage="gets the trip, sequence list and neighbours list";


Begin["`Private`"]


(*had to use N[] around pi due to a Sort[] error use later and If[] error*)
SumRadii[bubbleList_,plate_,opt_]:=Map[Function[dummy,
Which[
(opt==1),(#[[1]]+#[[2]]),
(opt==6),{(SmallFunctions`CenterDistance[#[[1]],#[[2]],N[Pi*60/180]]),(SmallFunctions`CenterDistance[#[[1]],#[[2]],N[Pi*60/180]])},
(opt==2),{(#[[1]]+#[[2]]),(#[[1]]+#[[2]])},
(opt==3),{(#[[1]]+#[[2]]),(SmallFunctions`CenterDistance[#[[1]],#[[2]],N[Pi*60/180]])},
(opt==10),(#[[1]]+#[[2]])+(#[[1]]*0.25)(*(EuclideanDistance[bubbleList[[1,1]][[1]],bubbleList[[2,1]][[1]]]*0.1)ambCol[[orSeqList[[dp,2]],1]]*)
]&@{SmallFunctions`MyaveFn[plate[[2]]],SmallFunctions`MyaveFn[dummy[[2]]]}],
bubbleList,{2}]


FindCloseNeighbours[radiiDist_,precisionFactor_]:=
If[((#[[1]])>=(#[[2]])||(SmallFunctions`LThanPrec[#[[1]],#[[2]],precisionFactor]==1)||(SmallFunctions`GreaterThan[#[[1]],#[[2]],precisionFactor]==0)),
1,0]&@radiiDist


FindExactDistanceNeighbours[radiiDist_,precisionFactor_]:=
If[((#[[1]])==(#[[2]])||(SmallFunctions`LThanPrec[#[[1]],#[[2]],precisionFactor]==1)||(SmallFunctions`GreaterThan[#[[1]],#[[2]],precisionFactor]==0)),
1,0]&@radiiDist


(*If[((radiiDist[[1,2]])==(radiiDist[[2]])||(SmallFunctions`LThanPrec[radiiDist[[1,2]],radiiDist[[2]],precisionFactor]\[Equal]1)||(SmallFunctions`GreaterThan[radiiDist[[1,2]],radiiDist[[2]],precisionFactor]\[Equal]0)),0,1]*)
OverlappingNeighbours[radiiDist_,precisionFactor_]:=
If[((#[[1,1]])>=(#[[2]])||(SmallFunctions`LThanPrec[#[[1,1]],#[[2]],precisionFactor]==1)||(SmallFunctions`GreaterThan[#[[1,1]],#[[2]],precisionFactor]==0)),
If[((#[[1,2]])==(#[[2]])||(SmallFunctions`LThanPrec[#[[1,2]],#[[2]],precisionFactor]==1)||(SmallFunctions`GreaterThan[#[[1,2]],#[[2]],precisionFactor]==0)),0,1],0]&@radiiDist


NeighBourFinderBasedOnDistance[allBubbleList_,onePlate_,precisionFactor_, opt_]:=Module[{location,dist,radiiDist,diffm,newDiffm,findVal,neighList,distOfNeigh},
location=Flatten[Position[allBubbleList,onePlate]];
(*finds the distance between the bubble of interest and all the others*)
dist = SmallFunctions`DistFromOnePlate[allBubbleList, onePlate[[1]]];
(*this list either contains the distance of two radii, or the plateau distance between two bubbles*)
radiiDist = SumRadii[allBubbleList,onePlate,opt];
(*opt 4 only cares about distance not radiidist*)
If[(opt==4)||(opt==5),diffm =Map[Transpose,Transpose[{dist,dist}]];,
(*this creates a list of the radii dist values and the actual distance of two bubbles*)
diffm =Map[Transpose,Transpose[{radiiDist,dist}]];];
If[((opt==4)||(opt==5)||(opt==3)||(opt==2)||(opt==1)||(opt==10)||(opt==6)),newDiffm=dist;,newDiffm=dist-radiiDist;diffm =Map[Transpose,Transpose[{newDiffm,radiiDist}]]];
(*findVall is a list that returns 1 for meeting the criteria and 0 for failing*)
Which[((opt==3)||(opt==2)||(opt==6)),findVal=Map[Function[dummy,OverlappingNeighbours[dummy,precisionFactor]],diffm,{2}];,
((opt==1)||(opt==10)||(opt==8)||(opt==9)),findVal=Map[Function[dummy,FindCloseNeighbours[dummy,precisionFactor]],diffm,{2}];,
(opt==4)||(opt==5),findVal=Map[Function[dummy,1],diffm,{2}];
];
(*removes itself from the list,then sort the neighbours based on distance*)
If[(opt==4),neighList=Position[findVal,1];,neighList =Complement[Position[findVal,1],{location}];];
(*gets the distances next to the neigh position for sorting*)
distOfNeigh= newDiffm[[#[[1]],#[[2]]]]&/@neighList;
If[opt==4,{distOfNeigh,neighList},
{location,Last/@Sort[Transpose[{distOfNeigh,neighList}]]}]

]


PairNeigh[nList_]:=If[nList=={},{},If[nList[[2]]=={},{},Table[{nList[[1]],nList[[2,i]]},{i,1,Length[nList[[2]]]}]]]


GetAllPairs[neighList_]:=Map[PairNeigh,neighList,{2}]


GetNeighInt[pairSet_,neighList_]:=Intersection[neighList[[#[[1,1]],#[[1,2]]]][[2]],neighList[[#[[2,1]],#[[2,2]]]][[2]]]&@pairSet


GetNeighPairsInfoList[neighList_]:=Module[{pList,nList,lastInfo},
pList=Union[Sort/@Flatten[GetAllPairs[neighList],2]];
nList={};
Map[Function[dummy,
If[dummy=={},{},
(*this checks to see if the pairs are really neighbours of one another and not just one sided*)
If[(MemberQ[neighList[[dummy[[1,1]],dummy[[1,2]]]][[2]],dummy[[2]]]==True)&&(MemberQ[neighList[[dummy[[2,1]],dummy[[2,2]]]][[2]],dummy[[1]]]==True),
AppendTo[nList,{dummy,GetNeighInt[dummy,neighList]}];
];
];],pList];
(*pairs the neigh with each bubble
lastInfo=Map[Function[dummy,If[dummy\[Equal]{},{},If[(dummy[[1]]\[Equal]{}||dummy[[2]]\[Equal]{}),{},Map[Sort,Join[ PairNeigh[{dummy[[1,1]],dummy[[2]]}], PairNeigh[{dummy[[1,2]],dummy[[2]]}]]]]]],nList];*)
Transpose[{Map[First,nList],Map[Last,nList]}]
]


PerpenSortInfoList[allSeq_,allBubbleList_]:=Module[{bublist,mid,slp1,slp2,pairIn, newSeqList,centList,centAng,centQuad,neighCent,neighList,thRange,neighAng,sideOfBub,sideList,sideList2,allneighIn,perPen,ang,thRange2,angRes,radiiList,d},
newSeqList=allSeq;
pairIn=newSeqList[[1]];

bublist={allBubbleList[[pairIn[[1,1]],pairIn[[1,2]]]],allBubbleList[[pairIn[[2,1]],pairIn[[2,2]]]]};
centList=Map[First,bublist];
neighList=allBubbleList[[#[[1]],#[[2]]]]&/@newSeqList[[2]];
neighCent=Map[First,neighList];
mid=SmallFunctions`FindmidPoint[centList];
(*finds the angle of the two bubbles relative to the midPoint*)
centAng={SmallFunctions`AngleAroundThePlate[(centList[[1]]-mid)],SmallFunctions`AngleAroundThePlate[(centList[[1]]-mid)],SmallFunctions`AngleAroundThePlate[(centList[[2]]-mid)]};
centQuad=Map[SmallFunctions`QuadAngle,centAng];
(*this sorts the centers from least to greater quad number*)
(*centAng=Map[Last,Sort[Transpose[{centQuad,centAng}]]];*)
(*this finds the ang and the quad for the bub*)
neighAng=SmallFunctions`AngleAroundThePlate[(#-mid)]&/@neighCent;
(*then gets the range that the bub should fit in*)
thRange=SmallFunctions`OrderThetaQuad[{centAng,centQuad}];
(*this is for a check the bubble cannot be on the same slope as the pairs but also i make the range pi/8, not 45 bit near the top removes wrong neighs*)
radiiList=SmallFunctions`MyaveFn[Take[#,{2}][[1]]]&/@bublist;
d=SmallFunctions`DistancebtwPoints[ centList[[1]],centList[[2]]];
(*this is an important line, it determines neighours based on the size of the bubbles, when they are equal the range is different than when they are the unequal, the angle range is calculated using the radius and the distance of the bubbles*)
angRes=N[{ArcTan[radiiList[[1]]/d],ArcTan[radiiList[[2]]/d]}];
ang={{centAng[[1]],SmallFunctions`CheckAngle[centAng[[1]]+(angRes[[1]])],SmallFunctions`CheckAngle[centAng[[1]]-(angRes[[1]])]},{centAng[[3]],SmallFunctions`CheckAngle[centAng[[3]]+(angRes[[2]])],SmallFunctions`CheckAngle[centAng[[3]]-(angRes[[2]])]}};
thRange2=Map[Function[dummy,SmallFunctions`OrderThetaQuad[{dummy,Map[SmallFunctions`QuadAngle,dummy]}]],ang];
(*now it decides which side the neigh goes on*)
perPen=SmallFunctions`RotateCurve[centList, N[Pi/2],mid];

sideList={{},{}};
Map[Function[dummy,
If[((SmallFunctions`MatchRange2[thRange2[[1]],dummy[[1]]]==0)&&(SmallFunctions`MatchRange2[thRange2[[2]],dummy[[1]]]==0)),
(*closest to perpen slope, sorting by distance *)
slp1=Min[{SmallFunctions`DistancebtwPoints[ perPen[[1]],dummy[[2]]],SmallFunctions`DistancebtwPoints[ perPen[[2]],dummy[[2]]]}];
If[SmallFunctions`MatchRange[thRange,dummy[[1]]]==1,AppendTo[sideList[[1]],{slp1,dummy[[3]]}];,AppendTo[sideList[[2]],{slp1,dummy[[3]]}];
];
];
],Transpose[{neighAng,neighCent, newSeqList[[2]]}]];

(*this is necessary to separate to prevent the {} error*)
sideList[[1]]=If[sideList[[1]]=={},{},Sort[sideList[[1]]]];
sideList[[2]]=If[sideList[[2]]=={},{},Sort[sideList[[2]]]];
sideList[[1]]=If[sideList[[1]]=={},{},First[sideList[[1]]]];
sideList[[2]]=If[sideList[[2]]=={},{},First[sideList[[2]]]];
(*finally it appends the neigh to the list*)
newSeqList[[2]]={};
If[#!={},AppendTo[newSeqList[[2]],Last[#]];
newSeqList[[2]]=Sort[newSeqList[[2]]];
]&/@Sort[sideList];
(*newSeqList[[2]]=If[newSeqList[[2]]\[Equal]{},{},Sort[newSeqList[[2]]]];*)
newSeqList
]


CheckForWrongPairs[bubSet_,triplettes_]:=Map[Function[dummy,{Length[dummy],MemberQ[{Intersection[Sort[dummy],Sort[bubSet]]},Sort[bubSet]]}],triplettes]


CheckForWrongTrips[pairs_, thirdP_,infoList_]:=Module[{allp,posit,inter,trip},
allp=Map[First,infoList];
trip=Map[Sort,{pairs, {pairs[[1]], thirdP},{pairs[[2]], thirdP}}];
posit=Flatten[Map[Function[dummy, Position[allp,dummy]],trip]];
inter=Map[Function[dummy,Map[Function[dummy2,If[MemberQ[{pairs[[1]],pairs[[2]],thirdP},dummy2]==True,1,0]],infoList[[dummy,2]]]],posit];
Map[Function[dummy,If[MemberQ[dummy,1]==True,1,0]],inter]
]


GetTripsFromAllSeqInfo[allInfo_]:=Module[{tp},
tp={};
(*first we make trips and pairs from the results*)
Map[Function[dummy, 
If[dummy[[2]]=={},AppendTo[tp,Sort[dummy[[1]]]];,
Map[Function[dummy2,AppendTo[tp,Sort[Join[dummy[[1]],{dummy2}]]];],dummy[[2]]]
];
],allInfo];
tp]


TripNeighbourFinder3ofakind[allInfo_,sequenceList_]:=Module[{nList,newneigh,tp,pairList,newtp,newtpt,newtpp,s,n,pos1,temp,chk},
(*this functions determines correct triplettes or pairs*)
(*if 3 of the same trips are created means it is a correct ineraction, if 2 pairs are created means they are correct, if only 2or 1/3 trips are created then one of the neigh is not correct*)
(*first we make trips and pairs from the results*)

tp=GetTripsFromAllSeqInfo[allInfo];
(*removes tripletes are are not shared*)

newtp=newtpt=newtpp={};
Map[Function[dummy, 
If[((((Length[dummy]==2)&&(Count[CheckForWrongPairs[dummy, Union[tp]],{3,True}])==0))),AppendTo[newtp,SmallFunctions`SBySequence[sequenceList,dummy]];,
If[(Count[tp,dummy]>=(Length[dummy])),AppendTo[newtp,SmallFunctions`SBySequence[sequenceList,dummy]];];
];
],Union[tp]];


(*this puts trips first in the list*)
(*newtpt=SmallFunctions`SaListBySequence[sequenceList,newtpt];
newtpp=SmallFunctions`SaListBySequence[sequenceList,newtpp];
newtp=Join[newtpt,newtpp];*)
newtp=SmallFunctions`SaListBySequence[sequenceList,newtp];
(*if there is a bubble Missing then it will add the trip avaiable for that*)


chk=Complement[sequenceList,Union[Flatten[newtp,1]]];

If[Length[chk]>0,
Map[Function[dumy1,
temp={};
Map[Function[dummy,
If[MemberQ[dummy,dumy1]==True,AppendTo[temp,SmallFunctions`SBySequence[sequenceList,dummy]];
];
 ],Union[tp]];
(*makes sure that the found pairs/trips doesnt already exist*)
temp=Complement[temp,newtp];
temp=SmallFunctions`SaListBySequence[sequenceList,temp];
If[temp != {},AppendTo[newtp,temp[[1]]]];
],chk];
];

newtp=SmallFunctions`SBySequence[sequenceList,#]&/@newtp;
SmallFunctions`SaListBySequence[sequenceList,newtp]
]


TripNeighbourFinder2[allInfo_,sequenceList_]:=Module[{nList,newneigh,tp,stp,pL,tL,sL,cpL,pos,npL,tempt,tempp ,temp2,allpairs,newtp,newtpt,newtpp,s,n,t,p,temp,chk,flag},
(*first we make trips and pairs from the results*)
tp=GetTripsFromAllSeqInfo[allInfo];
(*to pick the first trip, i uses a function that only keeps trips or pairs that occur 3/2 times within the list*)
(*this functions determines correct triplettes or pairs*)
(*if 3 of the same trips are created means it is a correct ineraction, if 2 pairs are created means they are correct, if only 2or 1/3 trips are created then one of the neigh is not correct*)
stp=TripNeighbourFinder3ofakind[allInfo,sequenceList];
tL={Sort[stp[[1]]]}; (*final trip or pair list*)
pL=Union[Map[Sort,Permutations[stp[[1]],{2}]]]; 
(*final trip or pair list*)
sL=stp[[1]];(*a list which keeps track of the bubbles accounted for*)
pL=Map[Sort,pL];(*pair list*)
cpL={};(*list of pairs that shouldnt be together*)
newtp={{Sort[tL[[1]]],pL}};(*(chosen trip or pair), (permutations)*)
(*this gets all the first pairs in the info list*)
allpairs=Map[First,allInfo];
n=1;
While[(n<=Length[newtp]),
tempp=newtp[[n]];

flag=0;
If[tempp[[1]]!= {},
If[MemberQ[cpL,#]==True,
flag=1;]&/@Union[Map[Sort,Permutations[tempp[[1]],{2}]]];
];
If[flag==0,
(*this stores the trips and gets the pairs*)
If[tempp[[1]]!= {},
If[MemberQ[tL, Sort[tempp[[1]]]]==False,
AppendTo[tL,Sort[tempp[[1]]]];
sL=Union[Join[sL,tempp[[1]]]];
pL={};
pL=Join[pL,Union[Map[Sort,Permutations[#,{2}]]]]&/@tL;
];
];
(*from each pair it gets the next trips in order*)
If[tempp[[2]]!= {},
Map[Function[dummy2, 
pos=Flatten[Position[allpairs,dummy2]];
If[pos!= {},
(*this is a list of all the pairs*)
temp=allInfo[[pos[[1]],2]];
(*one of the bubbles have to be part of the trip*)
If[(Length[temp]>1)&&(Length[Intersection[tempp[[1]],temp]]>0),
(*this stores a list that has pairs of bubbles that should not be paired together, this list depends on the bubble you start with*)
cpL=Union[AppendTo[cpL,Sort[temp]]];
(*it doesnt keep the bubble that already was used*)
temp=Complement[temp,tempp[[2]]];
(*if the triplete is new then it appends {tripletes, pairs} to the list*)
Map[Function[dummy3,t={Sort[Join[dummy2,{dummy3}]],{}};
(*here is makes sure it is a new trip*)
If[MemberQ[tL, t[[1]]]==False,
(*keeps only new pairs*)
p=Complement[ {Sort[{dummy2[[1]],dummy3}],Sort[{dummy2[[2]],dummy3}]},pL];
If[MemberQ[cpL,#]== False,AppendTo[t[[2]],Sort[#]]]&/@p;
If[MemberQ[newtp, t]==False,AppendTo[newtp,t]];
];
],temp];
 ];
]],tempp[[2]]]
]];
n++;
flag=0;
s=1;
(*if n> length of newtp then this function checks to makes sure that all the bubbles were accounted for*)
chk=SmallFunctions`SBySequence[sequenceList,Complement[sequenceList,sL]];
If[((Length[chk]>0 )&& (n>Length[newtp])),
While[flag==0,
npL=chk[[s]];
temp2={};
(*finds all the trips that have that bubble*)
If[MemberQ[#,npL]==True,AppendTo[temp2,Sort[#]]]&/@Union[tp];
(*makes sure that the found pairs/trips doesnt already exist*)
temp2=Complement[temp2,tL];
(*if for some reason a bubble is not touching any other bubble is just ingnore it and adds it to the sequencelist*)
If[temp2=={},AppendTo[sL,chk[s]];
(*if there are other bubbles missing then it goes to the next one, otherwise it sets flag =1 which means get out of the loop*)
If[Length[chk]==1,flag=1];,
temp2=SmallFunctions`SaListBySequence[sequenceList,temp2];
Map[Function[dummy5,
If[(Length[dummy5]==3)||((((Length[dummy5]==2)&&(Count[CheckForWrongPairs[dummy5, Union[tp]],{3,True}])==0))),
p=Union[Map[Sort,Permutations[dummy5,{2}]]];
Map[Function[dummy4,If[(MemberQ[cpL,dummy4]==False)&&(Length[Intersection[sL,dummy5]]>0),
flag=1;
AppendTo[newtp,{dummy5,p}];
]],p];
];
],temp2];
];
s++;
];
];
];
SmallFunctions`SBySequence[sequenceList,#]&/@tL
]


TripNeighbourFinder2a[allInfo_,sequenceList_]:=Module[{nList,newneigh,tp,stp,pL,tL,sL,cpL,pos,npL,tempt,tempp ,temp2,allpairs,newtp,newtpt,newtpp,s,n,t,p,temp,chk,flag,h},
(*first we make trips and pairs from the results*)
tp=GetTripsFromAllSeqInfo[allInfo];
(*to pick the first trip, i uses a function that only keeps trips or pairs that occur 3/2 times within the list*)
(*this functions determines correct triplettes or pairs*)
(*if 3 of the same trips are created means it is a correct ineraction, if 2 pairs are created means they are correct, if only 2or 1/3 trips are created then one of the neigh is not correct*)
stp=TripNeighbourFinder3ofakind[allInfo,sequenceList];
tL={Sort[stp[[1]]]}; (*final trip or pair list*)
pL=Union[Map[Sort,Permutations[stp[[1]],{2}]]]; (*final trip or pair list*)
sL=stp[[1]];(*a list which keeps track of the bubbles accounted for*)
pL=Map[Sort,pL];(*pair list*)
cpL={};(*list of pairs that shouldnt be together*)
newtp={{Sort[tL[[1]]],pL}};(*(chosen trip or pair), (permutations)*)
(*this gets all the first pairs in the info list*)
(*If[(Length[newtp[[1,2]]]\[Equal]1)&&(Sort[newtp[[1,1]]]\[Equal]Sort[newtp[[1,2]][[1]]]),
AppendTo[newtp,{Sort[stp[[2]]],Union[Map[Sort,Permutations[stp[[2]],{2}]]]}];];*)
allpairs=Map[First,allInfo];
n=1;
While[(n<=Length[newtp]),
tempp=newtp[[n]];
flag=0;
(*this checks if the trip or pair are not in cpl*)
Map[Function[dummy4,If[MemberQ[cpL,dummy4]==True,
flag=1;]],Union[Map[Sort,Permutations[tempp[[1]],{2}]]]];

If[flag==0,
(*this stores the trips and gets the pairs*)
If[tempp[[1]]!= {},
If[(MemberQ[tL, Sort[tempp[[1]]]]==False)&&(((((Length[tempp[[1]]]==2)&&(Count[CheckForWrongPairs[tempp[[1]], Union[tp]],{3,True}])==0)))||((((Length[tempp[[1]]]==2)&&(Count[CheckForWrongPairs[tempp[[1]], Union[tL]],{3,True}])==0)))),(*makes sure it doesnt already exist*)
AppendTo[tL,Sort[tempp[[1]]]];(*puts it in the final list*)
sL=Union[Join[sL,tempp[[1]]]];(*a list which keeps track of the bubbles accounted for*)
(*starts a new pair list for the trips*)
pL=Join[{},Union[Map[Sort,Permutations[#,{2}]]]]&/@tL;
];
];
(*from each pair it gets the next trips in order*)
(*If[Length[tempp[[2]]]\[Equal]1,
chk=SmallFunctions`SBySequence[sequenceList,Complement[sequenceList,sL]];
pL={};(*starts a new pair list for the trips*)
Map[Function[dummy4,
pL=Join[pL,Union[Map[Sort,Permutations[dummy4,{2}]]]]],{Join[{chk[[1]]},tempp[[1]]]}];
tempp[[2]]==Intersection[allpairs,pL];
Print[tempp];
];*)
If[tempp[[2]]!= {},
Map[Function[dummy2, 
pos=Flatten[Position[allpairs,dummy2]];
(*this is a list of all the pairs*)
temp=allInfo[[pos[[1]],2]];
(*one of the bubbles have to be part of the trip*)
If[(Length[temp]>1)&&Length[Intersection[tempp[[1]],temp]]>0,
(*this stores a list that has pairs of bubbles that should not be paired together, this list depends on the bubble you start with*)
cpL=Union[AppendTo[cpL,Sort[temp]]];
(*it doesnt keep the bubble that already was used*)
temp=Complement[temp,tempp[[2]]];
(*if the triplete is new then it appends {tripletes, pairs} to the list*)
Map[Function[dummy3,t={Sort[Join[dummy2,{dummy3}]],{}};
(*here is makes sure it is a new trip*)
If[MemberQ[tL, t[[1]]]==False,
(*keeps only new pairs*)
p=Complement[ {Sort[{dummy2[[1]],dummy3}],Sort[{dummy2[[2]],dummy3}]},pL];
Map[Function[dummy4,If[MemberQ[cpL,dummy4]== False,
AppendTo[t[[2]],Sort[dummy4]]]],p];
If[MemberQ[newtp, t]==False,AppendTo[newtp,t]];
];
],temp];
 ];
],tempp[[2]]]
]];

n++;
flag=0;
s=1;
(*if n> length of newtp then this function checks to makes sure that all the bubbles were accounted for*)
(*sometimes when there are two bubbles fixed and are the starting two bubbles they may not be triplets and so the sequence does not continue*)
(*so this function makes sure that it check for other bubbles that contain one of the fixed bubbles
If[(n>Length[newtp])&&(Length[tempp[[2]]]\[Equal]1)&&(Sort[tempp[[1]]]\[Equal]Sort[tempp[[2,1]]]),chk=Union[Flatten[Complement[Map[Function[dummy,SmallFunctions`SBySequence[sequenceList,dummy]],stp],Map[Function[dummy,SmallFunctions`SBySequence[sequenceList,dummy]],tL]],1]];
chk=SmallFunctions`SBySequence[sequenceList,chk];,];*)
chk=SmallFunctions`SBySequence[sequenceList,Complement[sequenceList,sL]];
If[((Length[chk]>0 )&& (n>Length[newtp])),
While[(flag==0)||(n>Length[newtp]),
npL=chk[[s]];
temp2={};
(*finds all the trips that have that bubble*)
If[MemberQ[#,npL]==True,AppendTo[temp2,Sort[#]];
]&/@stp;
If[temp2=={},
If[MemberQ[#,npL]==True,AppendTo[temp2,Sort[#]];]&/@Union[tp];
temp2=SmallFunctions`SBySequence[sequenceList,#]&/@temp2;
temp2=SmallFunctions`SaListBySequence[sequenceList,temp2];
];
(*if for some reason a bubble is not touching any other bubble is just ingnore it and adds it to the sequencelist*)
If[temp2=={},AppendTo[sL,chk[s]];
(*if there are other bubbles missing then it goes to the next one, otherwise it sets flag =1 which means get out of the loop*)
If[Length[chk]==1,flag=1];,
Map[Function[dummy5,
If[(Length[dummy5]==3)||((((Length[dummy5]==2)&&(Count[CheckForWrongPairs[dummy5, Union[tp]],{3,True}])==0))),
p=Union[Map[Sort,Permutations[dummy5,{2}]]];
h={};
If[(MemberQ[cpL,Sort[#]]==False)(*&&(Length[Intersection[sL,dummy4]]>0)*),
AppendTo[h,1];(*AppendTo[newtp,{dummy4,p}];*),AppendTo[h,0];]&/@p;
If[Union[h]=={1},If[MemberQ[tL, Sort[dummy5]]==False,(*makes sure it doesnt already exist*)
AppendTo[tL,Sort[dummy5]];(*puts it in the final list*)
sL=Union[Join[sL,dummy5]];(*a list which keeps track of the bubbles accounted for*)
pL={};(*starts a new pair list for the trips*)
pL=Join[{},Union[Map[Sort,Permutations[#,{2}]]]]&/@tL;
];flag=1;
If[MemberQ[newtp,{Sort[dummy5],pL}]==False,AppendTo[newtp,t]];AppendTo[newtp,{Sort[dummy5],pL}]];
];
],temp2];
];
s++;
];
];
];

(*Print["tp-->",tp];
Print["tL-->",Map[Function[dummy,SmallFunctions`SBySequence[sequenceList,dummy]],tL]];
Print["stp-->",stp];
Print["pl-->",pL];
Print["sL-->", sL]
Print["stp-->",stp];;*)
SmallFunctions`SBySequence[sequenceList,#]&/@tL

]


GetAveDistance[allBubbleList_,plateB_,precisionFactor_,opt_]:=Module[{neighList,addDist,dist},
(*finds a sequence based on more than one plate or one plate as a fixed point*)
neighList=NeighBourFinderBasedOnDistance[allBubbleList,allBubbleList[[#[[1]],#[[2]]]],precisionFactor,opt]&/@plateB;
dist=First/@neighList;
addDist=Map[SmallFunctions`MyaveFn, Transpose[dist]];
Sort[Transpose[{addDist,neighList[[1,2]]}]]
]


GetASequenceForCol[allBubbleList_, fixedBub_,precisionFactor_]:=Module[{sequenceList,pairList, newPairList,nPlts,nonApiPlts,allPairs,newNList,distOfNeigh,dist,radiiDist,newF,colNum,temp,d,mslope,orslope,ang,quadA,tRange},
dist=Map[Last,GetAveDistance[allBubbleList,{fixedBub[[1]]},precisionFactor,4]];
nPlts=Length[dist];
(*takes the first in the list*)
sequenceList=Take[dist,1];
(*gets the distance of all the bubble relative to the first one*)
dist=GetAveDistance[allBubbleList,sequenceList,precisionFactor,4];
(*get the angle for all the bubbles relative to one*)
mslope=
SmallFunctions`mirrorAngle[SmallFunctions`AngleAroundThePlate[allBubbleList[[#[[1]],#[[2]]]][[1]]-allBubbleList[[Last[sequenceList][[1]],Last[sequenceList][[2]]]][[1]]]]&/@(Last/@dist);
(*the slope chosen to start is based on first bubble to the last bubble*)
radiiDist=Last[mslope];
(*increment can be anything we want the smaller the better*)
d=N[Pi/100000000];
While[((Length[sequenceList]<nPlts)),
(*finds all the plates with distance relative to the bubble in the sequencelist*)
ang=Map[SmallFunctions`CheckAngle,N[{radiiDist,(radiiDist+d),(radiiDist-d)}]];
quadA=Map[SmallFunctions`QuadAngle,ang];
tRange={SmallFunctions`OrderThetaQuad[{{#[[1,1]],#[[1,1]],#[[1,2]]},{#[[2,1]],#[[2,1]],#[[2,2]]} }],
SmallFunctions`OrderThetaQuad[{{#[[1,1]],#[[1,1]],#[[1,3]]},{#[[1,1]],#[[1,1]],#[[1,3]]} }]}&@{ang, quadA};
newPairList={};
(*finds the bubbles that fall within that angle range, and then sorts then by distance*)
If[(SmallFunctions`MatchRange[tRange[[1]],#[[2]]]==1)||(SmallFunctions`MatchRange[tRange[[2]],#[[2]]]==1),
If[MemberQ[sequenceList,#[[3]]]==False,
AppendTo[newPairList,#];
];
]&/@Transpose[{Map[First,dist],mslope,Map[Last,dist]}];
If[newPairList != {},sequenceList=Join[sequenceList,Map[Last,Sort[newPairList]]]];
d++;
];(*while*)
sequenceList
]


GetClosestBub[plateB_,allBubbleList_,precisionFactor_,opt_:1]:=Module[{ post},
(*dist=SmallFunctions`DistFromOnePlate[allBubbleList,plateB[[1]]]; should i compare with radii dist or should it be just physical distance?????*)
(*post=Map[Function[dummy,Map[Function[dummy2,{dummy2,Position[dist,dummy2]}],dummy]],dist];
post=Union[Flatten[post,1]];
Print[post];
If[opt\[Equal]1,Flatten[post[[1]]][[2]],Flatten[Map[Last,post],1]]*)
post=Map[Last,Sort[Transpose[NeighBourFinderBasedOnDistance[allBubbleList,plateB,precisionFactor,4]]]];
post[[2]]
]


SeqSortAllInfoList[allSeqInfo_,allBubbleList_,cpOpt_]:=If[(#[[2]]=={})||(Length[#[[2]]]==1),#, PerpenSortInfoList[#,allBubbleList]]&/@allSeqInfo


(*this finds the neighbours based on distance only,getClosestBub is neccessary so we dont have bubbles that dont move, they all need neihbours*)
GetAllcloseNeigh[allBubbleList_,precisionFactor_,opt_]:=Module[{temp},
Map[Function[dummy,temp=NeighBourFinderBasedOnDistance[allBubbleList,dummy,precisionFactor,opt];
If[(temp[[2]]=={}),{temp[[1]],{GetClosestBub[allBubbleList[[temp[[1,1]],temp[[1,2]]]],allBubbleList,precisionFactor,1]}},
temp]
],allBubbleList,{2}]
]



UpdateNeighList[neighList_,allBubbleList_,sequenceList_]:=Module[{newBubbleList},
(*this function updates new neighbours for each bubble and stores them in a list*)
newBubbleList=allBubbleList;
(newBubbleList[[#[[1]],#[[2]]]]=ReplacePart[newBubbleList[[#[[1]],#[[2]]]],Last[neighList[[#[[1]],#[[2]]]]],3])&/@sequenceList;
newBubbleList
]


LoopThroughThetas[storeRange_, angleTheta_]:=Module[{st,flag},
st=1;
flag=0;
While[((st<=Length[storeRange])&&(flag==0)),
flag=SmallFunctions`MatchRange[storeRange[[st]], angleTheta];
st++;
];
flag
]


SecondLevelNeighbourSorter[thetaRange_, neighList_,thetaList_]:=  Module[{storethetas,storethetas2,newList,tempCheck,tempCheck2,t},
storethetas={};
storethetas2={};
newList={};
For[t=1,t<=Length[thetaList],
If[storethetas=={},tempCheck={0};tempCheck2={0};,
tempCheck={LoopThroughThetas[storethetas,thetaList[[t,1]]]};
tempCheck2={LoopThroughThetas[storethetas2,thetaList[[t,1]]]};
];

If[tempCheck=={1}||tempCheck2=={1},
AppendTo[storethetas2,thetaRange[[t]]];
t++;
,
(*stores just the ones accepted*)
AppendTo[storethetas,thetaRange[[t]]];
(*stores all the bubls before*)
AppendTo[storethetas2,thetaRange[[t]]];
AppendTo[newList,neighList[[t]]];
t++;
];

];
newList
]


NeighbourAngle[plateCenter_,oneBubble_]:=Module[{ang,ang2, angList,quadPos,d1,d2,r1,r2},
d1=SmallFunctions`DistancebtwPoints[oneBubble[[1]],plateCenter[[1]]];
r1=SmallFunctions`MyaveFn[plateCenter[[2]]];
r2=SmallFunctions`MyaveFn[oneBubble[[2]]];
ang2=ArcTan[r2/d1];
ang=SmallFunctions`AngleAroundThePlate[oneBubble[[1]]-plateCenter[[1]]];
angList={ang,SmallFunctions`CheckAngle[ang-ArcTan[r2/d1]],SmallFunctions`CheckAngle[ang+ArcTan[r2/d1]]};
quadPos=SmallFunctions`QuadAngle/@angList;
{angList,quadPos}
]


allNeighboursAround[neighList_,allneigh_,allBubbleList_]:=Module[{onePlate,newNeigh,neighPlates,thetaQuad,thetaRange},
onePlate= allBubbleList[[neighList[[1,1]],neighList[[1,2]]]];
newNeigh=Join[neighList[[2]],SmallFunctions`SBySequence[#[[1]],Complement[#[[1]],#[[2]]]]&@{allneigh[[2]],neighList[[2]]}];
If[(newNeigh=={})||(neighList[[2]]=={}),
neighList
,
neighPlates=allBubbleList[[#[[1]],#[[2]]]]&/@newNeigh;
thetaQuad=NeighbourAngle[onePlate,#]&/@neighPlates;
thetaRange=Map[SmallFunctions`OrderThetaQuad,thetaQuad];
{neighList[[1]],SecondLevelNeighbourSorter[thetaRange,newNeigh,Map[First,thetaQuad]]}
]
]


GetallNeighboursAround[allBubbleList_,precisionFactor_,opt_:5]:=Module[{touchingNeigh,allneighbyDist},
touchingNeigh=GetAllcloseNeigh[allBubbleList,precisionFactor,1];
allneighbyDist=GetAllcloseNeigh[allBubbleList,precisionFactor,opt];
Map[Function[dummy2,Map[Function[dummy,allNeighboursAround[dummy[[1]],dummy[[2]],allBubbleList]],dummy2]],Map[Transpose,Transpose[{touchingNeigh,allneighbyDist}]]]
]


(*to figure out proper triplettes and sequence, it only needs the list the percisionFactor and a starting bubble, it doesnt care if it is interacting of close packing. neighbours change only based on the starting bubble*)
GetFinalTripList2[allBubbleList_,precisionFactor_,fixedBub_,opt_:5]:=Module[{finalTrips,sequenceList,allSeqIn,ngl},
sequenceList=GetASequenceForCol[allBubbleList,fixedBub,precisionFactor];
ngl=GetallNeighboursAround[allBubbleList,precisionFactor,opt];
allSeqIn=If[(#[[2]]=={})||(Length[#[[2]]]==1),#,PerpenSortInfoList[#,allBubbleList]]&/@GetNeighPairsInfoList[ngl];
finalTrips=TripNeighbourFinder2[allSeqIn,sequenceList];
{ngl,allSeqIn, sequenceList,finalTrips}
]


(*to figure out proper triplettes and sequence, it only needs the list the percisionFactor and a starting bubble, it doesnt care if it is interacting of close packing. neighbours change only based on the starting bubble*)
GetFinalTripList[allBubbleList_,precisionFactor_,fixedBub_]:=Module[{finalTrips,sequenceList,allSeqIn,ngl},
sequenceList=GetASequenceForCol[allBubbleList,fixedBub,precisionFactor];

ngl=GetAllcloseNeigh[allBubbleList,precisionFactor,1];

allSeqIn=If[(#[[2]]=={})||(Length[#[[2]]]==1),#,PerpenSortInfoList[#,allBubbleList]]&/@(GetNeighPairsInfoList[ngl]);

finalTrips=TripNeighbourFinder2[allSeqIn,sequenceList];
{ngl,allSeqIn, sequenceList,finalTrips}
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
