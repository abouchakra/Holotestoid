(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Plate Addittion: Using Descartes Theorem


Needs["SmallFunctions`"]


Needs["DescartesFunctions`"]


Needs["PlateGrowthFunctions`"]


Needs["NeighbourFindingFunctions`"]


BeginPackage["PlateAdditionFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


PlateAdditionFunctions::usage="This package is where the new plate addition functions are stored.";


GetNewPlateSize::usage="it is a function that determines size (descartes theorem) of a new plate";


GetNewPlatesInGrowthZone::usage="this functions gets the plate that is closest to the growth zone of an occular plate so it can calculate the size and insert a new plate";


GetNucleationPosition::usage="this functions gets the plate that is closest to the growth zone of an occular plate so it can calculate the size and insert a new plate";


AddingAllThePlate::usage="if there are multiple plates to be added at one time period it will add all of then by alternating columns without growth";


Begin["`Private`"]


GetNucleationPosition[ocular_,apicalsys_,precisionFactor_,ang_]:=Module[{mS,cenDist,moveM,posInfo,ocP,ocP2,angleRange},
(*posInfo=SmallFunctions`TomakeDistanceExact[occular,peristome,SmallFunctions`MyaveFn[occular[[2]]],precisionFactor,5];*)
mS=apicalsys[[1]]-ocular[[1]];
cenDist=SmallFunctions`DistancebtwPoints[apicalsys[[1]],ocular[[1]]];
(*cenDist1=SmallFunctions`DistancebtwPoints[apicalsys[[1]],apicalsys[[1]]-mslope];*)
moveM=((SmallFunctions`MyaveFn[ocular[[2]]])*((mS)/cenDist));
(*ocP find the periphery point for amb col, I use the center ocular[[1]]+ocP/2 for interamb col*)
ocP=ocular[[1]]-moveM;
ocP2=(ocular[[1]]+ocP)/2;
(*this finds the growth position for new plates on an occular, currently they occur between angles defined by the ambulacra sector size *)
(*posInfo[[2]]*)
SmallFunctions`RotateOneCurve[#[[1]],#[[2]],apicalsys[[1]]]&/@Transpose[{{ocP,ocP,ocP2,ocP2},ang}]

]


GetNewPlatesInGrowthZone[growthzones_,allBubbleList_,occ_,colAng_]:=Module[{arcLen,rL},(*idea is that for each occular plate there are growth areas flanking ones are for inter ambplates and the inner ones are for amb plates, so i will divide the growth zone into sections from the center of the plate, direction is towards/away from the periproct*)
(*it needs to know the growth region*)
(*it needs to know the  plate involved or near*)
(*it looks for common neighbours first*)
(*finds the raddii of the 3 bubbles close to the growth area*)
rL=Flatten[((PlateGrowthFunctions`PlateGrowthSize[#[[1]],{#[[2]]},{occ[[1]]}])&/@Transpose[{colAng,growthzones}])];
(*returns the size of 3 possible new plates, with calculated plate size to fit gap*)
Transpose[{growthzones,{{rL[[1]],rL[[1]]},{rL[[2]],rL[[2]]},{rL[[3]],rL[[3]]},{rL[[4]],rL[[4]]}}, {{},{},{},{}}}]
]


AddingAllThePlate[allBubbleList_,orderList_ , plateNum_,precisionFactor_,apicalS_, ambAng_:(Pi/10),npAng_:(8*Pi/180)]:=Module[{newBubbleList,ocular,growthPos,zoneNeigh,newPlates,pos,colAng,colRange,col},
newBubbleList = allBubbleList;
(*for SIZE amb col uses thenpAng, and the diffence between he npAng and amb ang is for int plate*)
colAng={ N[npAng/2],N[npAng/2],N[ambAng/2]-N[npAng/2],N[ambAng/2]-N[npAng/2]};
(*for rotation and positions*)
col={N[(npAng/2)],-N[(npAng/2)],N[ambAng/2],-N[ambAng/2]};
(*gets the occular and apical system*)
If[(*MemberQ[{5},dummy[[1]]]\[Equal]True,apicalS=dummy[[2]];,*)
MemberQ[{3},#[[1]]]==True,ocular=#[[2]]]&/@Transpose[{orderList,allBubbleList}];
(*gets the postion of new plate addition*)
growthPos=GetNucleationPosition[ocular[[1]],apicalS[[1]],precisionFactor,col];
newPlates=GetNewPlatesInGrowthZone[growthPos,allBubbleList,apicalS[[1]],colAng];
(*plateNum is a list which defines the side and type of plates added*)
(*plate addition, ,1 or 2=amb, 4 or 3 = int different sides*)
Map[Function[dummy,
pos=If[dummy<=2,Flatten[Position[orderList,2]],Flatten[Position[orderList,1]]];
newBubbleList[[pos[[1]]]]=AppendTo[newBubbleList[[pos[[1]]]],newPlates[[dummy]]];
],plateNum];
newBubbleList
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
