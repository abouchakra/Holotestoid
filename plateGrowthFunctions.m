(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Plate Growth: Growth based on distance from apex


Needs["SmallFunctions`"]


Needs["NeighbourFindingFunctions`"]


Needs["CoalescingOrClosePackingFunctions`"]


BeginPackage["PlateGrowthFunctions`"]


Unprotect["`*"];ClearAll["`*"];
(*unprotect and clear out old definitionsn-allows repeated loading and alterations*)


PlateGrowthFunctions::usage="This package is where plate growth functions are stored.";


PlateGrowthSize::usage="calculates the size for each plate based on the distance from the vertex suspended by an isocelese triangle";


GrowOneBubble::usage="calculates the growth for each bubble and update the list";


GrowthOfAmbZone::usage="calculates the growth for each bubble and then interacts them or coalesce them";


GrowthOfIntZone::usage="calculates the growth for each bubble and then interacts them or coalesce them";


GetPlateSizeforIntCol::usage="calculates the size of the plate based on their location in the column and angle";


GrowApiPer::usage="grows the apical system and peristome based on column length";


GetPlateSizeforAmbCol::usage="calculates all the size of amb plates and packs them based on their location in the column and angle";


GrowThenCoalesceORclosePackBubbles::usage="calculates the total growth for growth zone";


Begin["`Private`"]


PlateGrowthSize[theta_,oneBubble_,pao_]:=Module[{dist},
dist=SmallFunctions`DistancebtwPoints[oneBubble[[1]],pao[[1]]]; 
SmallFunctions`CenterDistance[dist,dist,theta]/2
]


getplateAngle[plateCenter_,oneBubble_,ang2_]:=Module[{ang, angList,quadPos},
ang=SmallFunctions`AngleAroundThePlate[oneBubble-plateCenter];
angList={ang,SmallFunctions`CheckAngle[ang-ang2],SmallFunctions`CheckAngle[ang+ang2]};
quadPos=SmallFunctions`QuadAngle[#]&/@angList;
(*SmallFunctions`OrderThetaQuad[thetaQuad]*)
{SmallFunctions`OrderThetaQuad[{{angList[[1]],angList[[1]],angList[[2]]},{quadPos[[1]],quadPos[[1]],quadPos[[2]]}}],SmallFunctions`OrderThetaQuad[{{angList[[1]],angList[[1]],angList[[3]]},{quadPos[[1]],quadPos[[1]],quadPos[[3]]}}]}
]


getPlateSide[cAng_,onePlate_,pao_]:=Module[{pt,ang,sidePtrn,range},
pt={};
sidePtrn={{},{}};
If[pao[[1,1]]==pao[[2,1]],
pt=Join [pt,getplateAngle[pao[[1,1]],pao[[3,1]],cAng]];
pt=Join [pt,getplateAngle[pao[[2,1]],pao[[3,1]],cAng]];
sidePtrn[[1]]={{1,0,1,0},{1,0,0,0},{0,0,1,0}};
sidePtrn[[2]]={{0,0,0,1},{0,1,0,0},{0,1,0,1}};
,
pt=Join [pt,getplateAngle[pao[[1,1]],pao[[2,1]],cAng]];
pt=Join [pt,getplateAngle[pao[[2,1]],pao[[1,1]],cAng]];
sidePtrn[[1]]={{0,1,1,0},{0,0,1,0},{0,1,0,0}};
sidePtrn[[2]]={{1,0,0,1},{1,0,0,0},{0,0,0,1}};];
ang={SmallFunctions`AngleAroundThePlate[onePlate[[1]]-#[[1,1]]],SmallFunctions`AngleAroundThePlate[onePlate[[1]]-#[[1,1]]],SmallFunctions`AngleAroundThePlate[onePlate[[1]]-#[[2,1]]],SmallFunctions`AngleAroundThePlate[onePlate[[1]]-#[[2,1]]]}&@pao;
range=SmallFunctions`MatchRange[#[[1]],#[[2]]]&/@Transpose[{pt,ang}];
(*Flatten[Position[sidePtrn,range]][[1]]*)
If[MemberQ[sidePtrn[[1]],range]==True,1,2]
]



GrowApiPer[bubList_,gZ_,ambAng_,info_,precisionFactor_,ps_:1,per_:0.2]:=Module[{ac,acp,oc,ge,cl1,tempgPos,anS,rL,newbub,ncl,pTip,distList,ll,lc},
(*apical system growth with length*)
newbub=bubList;
pTip = Flatten[Map[Function[dummy,If[MemberQ[info,dummy]==True,Position[info,dummy],-1]],{6,5,3,4,2}]];
cl1=EuclideanDistance[newbub[[pTip[[2]],1]][[1]],newbub[[pTip[[1]],1]][[1]]];
ncl=cl1-SmallFunctions`MyaveFn[newbub[[pTip[[2]],1]][[2]]]-SmallFunctions`MyaveFn[newbub[[pTip[[1]],1]][[2]]];

(*it doesnt allow the apical system to shrink*)
If[SmallFunctions`MyaveFn[{(cl1/2)*per,(cl1/2)*per}]<SmallFunctions`MyaveFn[newbub[[pTip[[2]],1]][[2]]],
newbub,
ac={(cl1/2)*per,(cl1/2)*per};
(*+SmallFunctions`MyaveFn[newbub[[pTip[[3]],1]][[2]]]*)
acp=newbub[[pTip[[2]],1]][[1]]+{0,SmallFunctions`MyaveFn[Abs[(newbub[[pTip[[2]],1]][[2]]-ac)]]};
newbub[[pTip[[2]],1]][[1]]=acp;
newbub[[pTip[[2]],1]][[2]]=ac;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Map[Last,Sort[Transpose[distList]]]];

(*length of column, which is the distance from the apical system to the peristome, so take the distance from the center of the apical system and the center of the plate then i need to add the radius of the last plate and the radius of the peristome*)
lc=Max[First/@Sort@Transpose[distList]]-(SmallFunctions`MyaveFn[ newbub[[#[[2]],1]][[2]]]+SmallFunctions`MyaveFn[newbub[[#[[5]],ll[[2]]]][[2]]]&@pTip);
(*-SmallFunctions`MyaveFn[newbub[[pTip[[3]],1]][[2]]]
-SmallFunctions`MyaveFn[newbub[[pTip[[4]],1]][[2]]]*)
oc=acp-{0,SmallFunctions`MyaveFn[ac]};ge=acp-{0,SmallFunctions`MyaveFn[ac]};
tempgPos=SmallFunctions`RotateOneCurve[#[[1]],#[[2]],acp]&/@Transpose[{{oc,ge,ge},N[{0, (gZ)/2, -(gZ)/2}]}];
anS=N[{ambAng[[1]],gZ-ambAng[[1]],gZ-ambAng[[1]]}];
rL=Flatten[(PlateGrowthFunctions`PlateGrowthSize[#[[1]],{#[[2]]},{acp}]&/@Transpose[{anS,tempgPos}])];
tempgPos=Transpose[{tempgPos,Transpose[{rL,rL}], Table[{},{i,1,Length[rL]}]}];
Which[#[[1]]==6,
newbub[[#[[2]],1]][[2]]=ac*ps;
ncl=lc+SmallFunctions`MyaveFn[ac]+(ac*ps)[[1]];
(*-SmallFunctions`MyaveFn[newbub[[d[[2]],1]][[2]]]*)
newbub[[#[[2]],1]][[1]]=acp-{0,ncl};
,
#[[1]]==4,newbub[[#[[2]]]]={tempgPos[[2]],tempgPos[[3]]};,
#[[1]]==3,newbub[[#[[2]]]]={tempgPos[[1]]};
]&/@Transpose[{{6,5,3,4,2},pTip}];

newbub
]
]



GrowApiPerBB[bubList_,pTip_,cl1_,gZ_,ambAng_,info_]:=Module[{ac,acp,oc,ge,tempgPos,anS,rL,newbub,ncl},
(*apical system growth with length*)
newbub=bubList;
ncl=cl1-SmallFunctions`MyaveFn[newbub[[pTip[[2]],1]][[2]]]-SmallFunctions`MyaveFn[newbub[[pTip[[1]],1]][[2]]];
(*it doesnt allow the apical system to shrink*)
If[SmallFunctions`MyaveFn[{(cl1/2)*0.2,(cl1/2)*0.2}]<SmallFunctions`MyaveFn[newbub[[pTip[[2]],1]][[2]]],
newbub,
ac={(cl1/2)*0.2,(cl1/2)*0.2};
acp=newbub[[pTip[[2]],1]][[1]]+{0,SmallFunctions`MyaveFn[Abs[(newbub[[pTip[[2]],1]][[2]]-ac)]]};
newbub[[pTip[[2]],1]][[2]]=ac;
oc=acp-{0,SmallFunctions`MyaveFn[ac]};ge=acp-{0,SmallFunctions`MyaveFn[ac]};
tempgPos=SmallFunctions`RotateOneCurve[#[[1]],#[[2]],acp]&/@Transpose[{{oc,ge,ge},N[{0, (gZ)/2, -(gZ)/2}]}];
anS=Map[N,{ambAng[[1]],gZ-ambAng[[1]],gZ-ambAng[[1]]}];
rL=Flatten@PlateGrowthFunctions`PlateGrowthSize[#[[1]],{#[[2]]},{acp}]&/@Transpose[{anS,tempgPos}];
tempgPos=Transpose[{tempgPos,Transpose[{rL,rL}], Table[{},{i,1,Length[rL]}]}];
Which[#[[1]]==6,
newbub[[#[[2]],1]][[2]]={(cl1)*0.2,(cl1)*0.2};
ncl=lc+SmallFunctions`MyaveFn[ac]+(cl1*0.2);
(*-SmallFunctions`MyaveFn[newbub[[d[[2]],1]][[2]]]*)
newbub[[#[[2]],1]][[1]]=acp-{0,ncl-SmallFunctions`MyaveFn[newbub[[#[[2]],1]][[2]]]};
,
#[[1]]==4,newbub[[#[[2]]]]={tempgPos[[2]],tempgPos[[3]]};,
#[[1]]==3,newbub[[#[[2]]]]={tempgPos[[1]]};
]&/@Transpose[{info,pTip}];
newbub
]
]


GetPlateSizeforIntCol[allbubList_,precisionFactor_,ambAng1_,ambAng_,lc_,ambS_,pn_,ps_,npAng_,pao_,opt_,fpn_,fplate_:0]:=Module[{m,p,i,r ,temp,anbOfC,nlc,angS,newbub,intCol,aplate,ngl,fList,sequenceList2,finalTrips, trip,str,newbub2,diff1,diff2,cl,startD,growthPos,side,tempINT,pi,countP,rang},
newbub=allbubList;
intCol={{}};
tempINT={{},{}};
(*starting int pos*)
If[ambAng1>ambAng,rang=N[ambAng1/2],rang=N[ambAng/2];];
rang=N[ambAng/2];
(*the angle and space and interaction for interambulacral plates is not figured out yet*)
(*If[rang<0.38,rang=rang/6,If[rang>0.6,rang=rang*4,rang=rang]];*)

growthPos=PlateAdditionFunctions`GetNucleationPosition[pao[[3]],pao[[2]],precisionFactor,{N[(npAng)/2],-N[(npAng)/2],N[ambAng1/2],-N[ambAng1/2]}];
growthPos=Take[growthPos,-2];
(*starding distance*)
startD=EuclideanDistance[pao[[2,1]],#]&/@growthPos;
(*the side determines which side the new plate is on*)
side=If[EvenQ[pn]==True, {-1,1},{1,-1}];
(*d[[3]], is for rotation*)
countP={0,0};
Map[Function[d,
p=d[[1]];

i=1;
(*since the column is not straight down have to calculated the length of the columns angled, so using hypotenuse triangle*)
anbOfC=Sqrt[(ambS^2)+((ambS*Tan[ambAng/2])^2)];
anbOfC=ambS;
r=0;
nlc=Sqrt[(lc^2)+((lc*Tan[ambAng/2])^2)];
cl=nlc-(ps);
diff1=diff2=p;
(*it stops when a new plate is added and the difference between the length of the column and the distance of the plate from the apical system is more than the previous step*)

pi=0;
countP[[d[[4]]]]=0;
While[(Abs[cl-diff1] >= Abs[cl-diff2])&&(pi<=fpn[[d[[4]]]]),
If[((i==1)&&(d[[2]]==-1)),angS=npAng;,angS=ambAng/2;];
temp=r;
If[(p>anbOfC)&&(anbOfC != 0),
If[fplate==1,pi++;
countP[[d[[4]]]]=fpn[[d[[4]]]];,countP[[d[[4]]]]=countP[[d[[4]]]]+1;];
(*If[((p>anbOfC)&&(fplates\[Equal]0))||((fplates\[Equal]1)&&(pn-pi \[LessEqual] fpN)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
If[((fopt\[Equal]1 )&& (pn-pi ==fpN)&&(fplates\[Equal]0)),
Print["Fixed ",pi];
fplates=1;
hd=EuclideanDistance[pao[[2,1]],ambCol[[orSeqList[[pi-1,2]]]][[1]]];
pao[[1,1]]=pao[[2,1]]-{0,2*hd};
newbub[[pTip[[1]],1]]=pao[[1]];
];
*)

r=SmallFunctions`CenterDistance[Abs[nlc-p],Abs[nlc-p],angS];
If[i>1,p=p+r/2-temp/2;];
r=SmallFunctions`CenterDistance[Abs[nlc-p],Abs[nlc-p],angS];

(*i havent figured out why yet but for in i need to substact and for amb i need to leave it as p*)
m={1,Abs[nlc-p],r/2};
,

If[((i==1)&&(d[[2]]==-1)),
(*first int plate is calculated by descartes*)

Which[opt==1,
r=DescartesFunctions`DescartesTheorem[SmallFunctions`MyaveFn[pao[[1,2]]],SmallFunctions`MyaveFn[pao[[2,2]]],SmallFunctions`MyaveFn[pao[[3,2]]]]*2;
If[i>1,p=p+r/2-temp/2;];
,
opt==0,
r=SmallFunctions`CenterDistance[p,p,angS];
If[i>1,p=p+r/2-temp/2;];
r=SmallFunctions`CenterDistance[p,p,angS];
];
,
r=SmallFunctions`CenterDistance[p,p,angS];
If[i>1,p=p+r/2-temp/2;];
r=SmallFunctions`CenterDistance[p,p,angS];
];
m={2,p,r/2};
];

(*rotate and get size of plate, d[[3]] determines the direction of rotation(If[ambAng1>ambAng,N[ambAng1/2],N[ambAng/2]])*)

aplate={SmallFunctions`RotateOneCurve[If[Abs[m[[1]]]==1,(pao[[Abs[m[[1]]],1]]+{0,m[[2]]}),pao[[m[[1]],1]]-{0,m[[2]]}],(If[Abs[m[[1]]]==1,-d[[3]],d[[3]]])*rang,pao[[m[[1]],1]]],{m[[3]],m[[3]]},{}};
AppendTo[intCol[[1]],aplate];
newbub2=Join[newbub,intCol];
(*Print[SmallFunctions`Drawcol[newbub2]];*)
fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub2,aplate,precisionFactor, 4]];

sequenceList2=NeighbourFindingFunctions`GetASequenceForCol[newbub2,{{1,1}},precisionFactor];

(*Print[SmallFunctions`Drawcol[newbub2]];*)
ngl=NeighbourFindingFunctions`GetFinalTripList2[newbub2,precisionFactor,{{1,1}},10];

finalTrips=ngl[[4]];
trip=Flatten[If[(MemberQ[#,fList[[1]]]==True)&&(Length[Intersection[#,fList]]==Length[#]-1),{#},{}]&/@finalTrips,1];

If[trip=={},
trip=Flatten[Map[Function[mem,If[MemberQ[mem,fList[[1]]]==True,{mem},{}]],finalTrips],1];];
intCol=CoalescingOrClosePackingFunctions`FnthatCPorCoalesce[trip[[1]],allbubList,newbub2, {trip[[1]]},sequenceList2,precisionFactor,fList,fList,1];

(*Print[SmallFunctions`Drawcol[intCol]];*)
intCol={Last[intCol[[2]]]};
AppendTo[tempINT[[d[[4]]]],Last[Last[intCol]]];
(*previous distance*)
diff1=p;
p=p+r;
(*new distance*)
diff2=p+r/2;
i++;
];
{m,(p)*Cos[ambAng/2],(p-(r/2))}
],Transpose[{startD,side,{-1,1},{1,2}}]];
{intCol,tempINT,countP}
]


GetNewFixedListBasedOnColAng[newbub2_,pao_, ambAng_, sequenceList_]:=Module[{pt,nfList,an,range},pt=getplateAngle[pao[[2,1]],pao[[1,1]],ambAng/2];
nfList={};
If[newbub2[[#[[1]],#[[2]]]][[1]]==pao[[2,1]],AppendTo[nfList,#];,
(*the peristome is omited*)
If[newbub2[[#[[1]],#[[2]]]][[1]]!= pao[[1,1]],
an=SmallFunctions`AngleAroundThePlate[newbub2[[#[[1]],#[[2]]]][[1]]-pao[[2,1]]];
range=Map[Function[dum,SmallFunctions`MatchRange[dum[[1]], dum[[2]]]],Transpose[{pt,{an,an}}]];
If[MemberQ[range,1]==True,AppendTo[nfList,#];]]]&/@sequenceList;
nfList
]


GetATripForThePlate[newbub2_, orSeqList_,pao_,pos_, aplate_,fp_,ambAng_,pTip_,precisionFactor_,opt_:5]:=Module[{sequenceList2, fList, fxList, nfList, ngl,finalTrips,trip},sequenceList2=NeighbourFindingFunctions`GetASequenceForCol[newbub2,{{pTip[[2]],1}},precisionFactor];

fList=Map[Last,Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub2,aplate,precisionFactor, 4]]]];
fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]])||((#[[1]]==pTip[[5]])&&(Flatten[Position[orSeqList,#],1][[1]]<Flatten[Position[orSeqList,fList[[1]]],1][[1]])),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*this section only fixes the plates within the angle region to get the right triplets*)
nfList=GetNewFixedListBasedOnColAng[newbub2,pao, ambAng, fxList];

(*ngl=NeighbourFindingFunctions`GetFinalTripList[newbub2,precisionFactor,{{pTip[[2]],1}}];
finalTrips=ngl[[4]];
Print["finalTrips",finalTrips];
trip=Flatten[Map[Function[mem,If[(MemberQ[mem,fList[[1]]]\[Equal]True)&&(Length[Intersection[mem,nfList]]\[Equal]Length[mem]-1),{mem},{}]],finalTrips],1];
trip=SmallFunctions`SaListBySequence[sequenceList2,trip];
(*if you couldnt find trips based on only all neigh  not just touching then it looks within all trips not just ones that reoccur *)
Print["Trips",trip];*)
ngl=NeighbourFindingFunctions`GetFinalTripList2[newbub2,precisionFactor,{{pTip[[2]],1}},opt];
finalTrips=ngl[[4]];
trip=Flatten[If[(MemberQ[#,fList[[1]]]==True)&&(Length[Intersection[#,nfList]]==Length[#]-1),{#},{}]&/@finalTrips,1];
trip=SmallFunctions`SaListBySequence[sequenceList2,trip];
(*if you couldnt find trips based on only all neigh  not just touching then it looks within all trips not just ones that reoccur *)

If[trip=={},
finalTrips=NeighbourFindingFunctions`GetTripsFromAllSeqInfo[ngl[[2]]];
(*this checks that all member are included in fixedlist or equal to the the plate*)
trip=Flatten[If[(MemberQ[#,fList[[1]]]==True)&&(Length[Intersection[#,nfList]]==Length[#]-1),{#},{}]&/@finalTrips,1];
trip=SmallFunctions`SaListBySequence[sequenceList2,trip];
];
{trip, sequenceList2,fxList}
]



getOrderOfPlates[distList_,newbub_,precisionFactor_,pTip_,pn_,pao_,ambAng_]:=Module[{sequenceList,ngl,sequenceList2,finalTrips,nfList,orSeqList,pos,fp,sides,orderS},(*sequence based on the distance from the apical system*)
sequenceList=Last/@Sort[Transpose[distList]];
(*drops the first item because it is the apical system and is not needed*)
sequenceList=Drop[sequenceList,1];
(*gets the new plates that are located within the column angle*)
ngl=NeighbourFindingFunctions`GetFinalTripList2[newbub,0.0001,{{pTip[[2]],1}},10];
sequenceList2=ngl[[3]];
(*Print[ngl[[1]]];
Print[ngl[[2]]];*)
finalTrips=ngl[[4]];
nfList=GetNewFixedListBasedOnColAng[newbub,pao, ambAng, sequenceList2];
(*AppendTo[nfList,{1,1}];*)
(*orSeqList={};
Map[Function[mem,If[(mem[[1]]==pTip[[5]])&&(MemberQ[orSeqList,mem]\[Equal]False),AppendTo[orSeqList,mem];]],sequenceList2];
Print[orSeqList];
(*get plate number*)

pos=Map[Last,orSeqList];
(*uses the position to determin the side of the plates and eventually determine the newest plate's location*)
sides=Map[Function[dum,getPlateSide[ambAng/2,dum,pao]],newbub[[pTip[[5]]]]];
orderS=Map[Function[k,sides[[k]]],pos];
(*position of the newest plate*)
fp=Flatten[Position[orderS, If[EvenQ[Length[newbub[[pTip[[5]]]]]]\[Equal]True,2,1]]][[1]];
(*drops the newest plate and then prepends it to the front of the list*)
orSeqList=Drop[orSeqList,{fp}];
PrependTo[orSeqList,{pTip[[5]],pos[[fp]]}];
sequenceList2=Join[SmallFunctions`SBySequence[sequenceList2,Complement[nfList,orSeqList]],orSeqList];*)
If[pn==1,
orSeqList={};If[(#[[1]]==pTip[[5]])&&(MemberQ[orSeqList,#]==False),AppendTo[orSeqList,#];]&/@nfList;,
sequenceList=Flatten[If[MemberQ[Map[First,#],pTip[[5]]]==True&&(Length[Intersection[#,nfList]]>=Length[#]-1),{#},{}]&/@finalTrips,1];
If[sequenceList=={},
ngl=NeighbourFindingFunctions`GetFinalTripList[newbub,precisionFactor,{{pTip[[2]],1}}];
finalTrips=ngl[[4]];
sequenceList=Flatten[If[MemberQ[Map[First,#],pTip[[5]]]==True&&(Length[Intersection[#,nfList]]==Length[#]),{#},{}]&/@finalTrips,1];
];
sequenceList=Map[Function[sq,
SmallFunctions`SBySequence[sequenceList2,sq]],sequenceList];
sequenceList=Flatten[SmallFunctions`SaListBySequence[sequenceList2,sequenceList],1];
orSeqList={};
If[(#[[1]]==pTip[[5]])&&(MemberQ[orSeqList,#]==False),AppendTo[orSeqList,#];]&/@sequenceList;
];
(*orSeqList*)
(*this function is not workin*)
(*Reverse[Sort[orSeqList]]*)
orSeqList
]


GetPlateSizeforAmbCol1[allbubList_,precisionFactor_,ambAng_,info_, npAng_,gZ_,pao1_,opt_,fopt_,fpN_,fixedP_,fpl_]:=Module[{m,p,i,r ,temp,anbOfC,nlc,angS,newbub,ambCol,aplate,ngl,fList,sequenceList,sequenceList2,finalTrips,n2, allSeqIn, trip,str,pTip,pn,distList,lc,fxList,sides,pos,orderS,sd,fp,pi,orSeqList,pao,nfList, an, pt, range,ll,rotA, alpha,newbub2,tempN,tempT,per,lc1,ambitus,fplates,hd,mp,pf,ll2,lc2,distList2,rp,distP,dp,stList,keepNeigh,abV,temD},
newbub=allbubList;
pao=pao1;
fplates=fixedP;
keepNeigh={};
(*location of all the different types of plates*)
pTip = Flatten[If[MemberQ[info,#]==True,Position[info,#],-1]&/@{6,5,4,3,2,1}];
abV=1;
(*gets the side for the newest plate*)
sides=getPlateSide[ambAng[[1]]/2,#,pao]&/@newbub[[pTip[[5]]]];
(*decides which side the new plate is on based on plate number*)
(*get plate number*)
pn=Length[newbub[[pTip[[5]]]]];
If[EvenQ[pn]==True,sd=2,sd=1];
(* get the distance of the column*)
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
(*farthest plate*)
ll=Last[Last/@Sort@Transpose[distList]];
(*length of column, which is the distance from the apical system to the peristome, so take the distance from the center of the apical system and the center of the plate then i need to add the radius of the last plate and the radius of the peristome*)
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
lc1=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*decides if the apical system grows based on the length of the column, the apical system changes size ONLY if it can increase it doesnt decrease*)
(**********************************)
(*newbub=GrowApiPer[newbub,pTip,lc,gZ,ambAng,{6,5,3,4,2,1}];
(*updates the pao list*)

newbub=GrowApiPer[newbub,gZ,ambAng,info,precisionFactor];
pao=Map[Function[dummy,If[dummy==-1,{},newbub[[dummy,1]]]],Take[pTip,4]];
lc=Max[Map[First,Sort[Transpose[distList]]]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
lc1=Max[Map[First,Sort[Transpose[distList]]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];*)
(*gets ambitus location from the apical system...distance*)
ambitus=(lc/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
r=0;
(*the length is adjusted to match the angle*)
nlc=Sqrt[(lc^2)+((lc*Tan[ambAng[[1]]/2])^2)];
distList=Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,newbub[[pTip[[2]],1]],precisionFactor, 4]]];
(*sequenceList=getOrderOfPlates[distList,newbub,precisionFactor,pTip,pn,pao,ambAng[[1]]];*)
sequenceList={};
If[(#[[1]]==pTip[[5]])&&(MemberQ[sequenceList,#]==False),AppendTo[sequenceList,#];]&/@Map[Last,distList];
(*sequenceList=Reverse[Sort[sequenceList]];*)
(*gets the position of the plates in the list to find the new plate*)
pos=Map[Last,sequenceList];
(*uses the position to determin the side of the plates and eventually determine the newest plate's location*)
orderS=Map[Function[k,sides[[k]]],pos];
(*position of the newest plate*)
fp=Flatten[Position[orderS, sd]][[1]];
(*drops the newest plate and then prepends it to the front of the list*)
orSeqList=Drop[sequenceList,{fp}];
PrependTo[orSeqList,{pTip[[5]],pos[[fp]]}];
orSeqList=Reverse[Sort[sequenceList]];
(*the order list is important to allow the plates to move in order to their location*)
pi=1;
rp=0;
stList={{pTip[[4]],1}};
While[pi<=pn,
(*get the ambcol only*)
ambCol=newbub[[pTip[[5]]]];
(*takes the plate of interest*)
aplate=ambCol[[orSeqList[[pi,2]]]];
(*gets the distance from the apical system*)
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
abV=1;
temp=r;
If[((p>anbOfC)&&(fplates==0))||((fplates==1)&&(pn+1-pi <= fpN)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
abV=2;
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
If[((fopt==1 )&& (pn+1-pi ==fpN)),
Print["Fixed ",pi];
fplates=1;
hd=EuclideanDistance[pao[[2,1]],ambCol[[orSeqList[[pi-1,2]],1]]];
Print[ambCol[[orSeqList[[pi-1,2]]]][[1]]];
ll2=hd+(hd-SmallFunctions`MyaveFn[pao[[2,2]]]) +SmallFunctions`MyaveFn[pao[[1,2]]](*+SmallFunctions`MyaveFn[pao[[3,2]]]*);
If[ll2>EuclideanDistance[pao[[2,1]],pao[[1,1]]],
pao[[1,1]]=pao[[2,1]]-{0,ll2};
newbub[[pTip[[1]],1]]=pao[[1]];
ambitus=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
,rp=1;
];
];

p=SmallFunctions`DistancebtwPoints[pao[[1,1]],aplate[[1]]];
r=SmallFunctions`CenterDistance[Abs[p],Abs[p],angS];
,
(*ONLY IF PLATES ARE FIXED*)
If[(fplates==1)&&(pi<=( pn-fpl)),
(*this used for sand dollars, it switches between petal and non petal angle*)
If[((pi==1)),angS=ambAng[[2]]*0.3/2;,angS=ambAng[[2]]/2;];
angS=ambAng[[2]]/2;,
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
];
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
If[((pi==1))&& (opt==1),
(*first amb plate is calculated by descartes if opt \[Equal]1*)
r=DescartesFunctions`DescartesTheorem[SmallFunctions`MyaveFn[pao[[1,2]]],SmallFunctions`MyaveFn[pao[[2,2]]],SmallFunctions`MyaveFn[pao[[3,2]]]]*2;
,
r=SmallFunctions`CenterDistance[p,p,angS];
];

];

If[rp==0,aplate[[2]]={r/2,r/2}];
ambCol[[orSeqList[[pi,2]]]]=aplate;
newbub[[pTip[[5]]]]=ambCol;

(*Print[SmallFunctions`Drawcol[newbub]];*)
If[pi==1,

(*angle btw occular and apical system*)
pt=SmallFunctions`AngleAroundThePlate[pao[[3,1]]-pao[[2,1]]];
(*angle location of a plate relative to the apical system center*)
an=SmallFunctions`AngleAroundThePlate[aplate[[1]]-pao[[2,1]]];
alpha=SmallFunctions`CosOfAngleC[p,p,r/2];
(*finds the amount and direction a plate must rotate to its new location*)
rotA=If[an> pt,(pt+alpha),(pt-alpha)];
(*gets the difference it needs to move from the original location*)
rotA=an-rotA;
aplate[[1]]=SmallFunctions`RotateOneCurve[aplate[[1]],rotA,pao[[2,1]]];
ambCol[[orSeqList[[pi,2]]]]=aplate;
(*first amb plate always interacts with the occular plate*)
ambCol=CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,0][[1]];

If[pn>1,
distP=ambCol[[orSeqList[[pi+1,2]],1]];
ambCol=CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi+1,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,1][[1]];
distP=ambCol[[orSeqList[[pi+1,2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=pi+2,dp<=Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
];
newbub[[pTip[[5]]]]=ambCol;

,

(*gets the sequence based on the original list*)
(*tempT=GetATripForThePlate[newbub, orSeqList,pao,pos, aplate,fp,ambAng[[1]],pTip,precisionFactor,10];
trip=tempT[[1]];
sequenceList2=tempT[[2]];
fxList=tempT[[3]];
*)
(*gets the sequence list and the fixed List to closepack*)
sequenceList2=NeighbourFindingFunctions`GetASequenceForCol[newbub,{{pTip[[2]],1}},precisionFactor];
fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,aplate,precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]])||((#[[1]]==pTip[[5]])&&(Flatten[Position[orSeqList,#],1][[1]]<Flatten[Position[orSeqList,fList[[1]]],1][[1]])),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*
Print["f",fxList];
Print["s",sequenceList2];
Print["t",trip];*)
(*Print["FXLIST",fxList];*)
(*if the old list doesnt produce any trip then we use the new list*)
(*If[trip\[Equal]{},
newbub2=newbub;
tempT=GetATripForThePlate[allbubList, orSeqList,pao,pos, aplate,fp,ambAng[[1]],pTip,precisionFactor];
trip=tempT[[1]];
sequenceList2=tempT[[2]];
fxList=tempT[[3]];
];
*)
(*then it close packs the trip*)


distP=ambCol[[orSeqList[[pi,2]],1]];
trip={Join[Take[stList,If[pi>2,-2,-1]],{{pTip[[5]],orSeqList[[pi,2]]}}]};
AppendTo[keepNeigh,trip[[1]]];
(*Print["st",stList];
Print["k",keepNeigh];
Print["o",orSeqList];
Print["t",trip];*)

tempN={1,newbub};
tempN=CoalescingOrClosePackingFunctions`FnthatCPorCoalesce[trip[[1]],newbub,tempN[[2]], {trip[[1]]},sequenceList2,precisionFactor,fxList,fxList,1];
newbub=tempN[[2]];

(*this readjusts the size if the distance changes*)
ambCol=newbub[[pTip[[5]]]];
p=SmallFunctions`DistancebtwPoints[#[[1]],ambCol[[orSeqList[[pi,2]],1]]]&@If[abV==1,pao[[2]],pao[[1]]];
r=SmallFunctions`CenterDistance[p,p,angS];
ambCol[[orSeqList[[pi,2]],2]]={r/2,r/2};
newbub[[pTip[[5]]]]=ambCol;


(*then closepacks again*)
tempN={1,newbub};
tempN=CoalescingOrClosePackingFunctions`FnthatCPorCoalesce[trip[[1]],newbub,tempN[[2]], {trip[[1]]},sequenceList2,precisionFactor,fxList,fxList,1];
newbub=tempN[[2]];

(*moves the other plates to match the changes, so the whole column maintians relative position*)
If[pi>2,
ambCol=newbub[[pTip[[5]]]];
distP=ambCol[[orSeqList[[pi,2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=pi+1,dp<=Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
newbub[[pTip[[5]]]]=ambCol;
];
(*Print[SmallFunctions`Drawcol[newbub]];*)
If[((pn-pi ==0)&&(fplates==1)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
distList2=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll2=Last[Last/@Sort@Transpose[distList2]];
lc2=Max[First/@Sort@Transpose[distList2]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*Print["***",EuclideanDistance[pao[[2,1]],pao[[1,1]]]];*)
If[lc2<EuclideanDistance[pao[[2,1]],pao[[1,1]]],
mp=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]-lc2)/(2fpN);
ambCol=newbub[[pTip[[5]]]];
For[pf=1,pf<=(fpN),
ambCol[[Length[ambCol]-pf,2]]=ambCol[[Length[ambCol]-pf,2]]+{mp,mp};
pf++;
];
newbub[[pTip[[5]]]]=ambCol;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
If[(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
];
];

];

distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];
(*Print[SmallFunctions`Drawcol[newbub]];*)
];

If[pn>1,

sequenceList2=Join[{{pTip[[2]],1}},{{pTip[[4]],1}},orSeqList,{{pTip[[1]],1}}];

fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,aplate,precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]]),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*then it close packs the trip*)

newbub=CoalescingOrClosePackingFunctions`InteractTrips[sequenceList2,Partition[Join[{{pTip[[4]],1}},orSeqList],3,1],newbub,precisionFactor,fxList,1];
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];

ambCol=newbub[[pTip[[5]]]];
distP=ambCol[[First[orSeqList][[2]],1]];
fxList={};
If[MemberQ[pTip[[3;;6]],#[[1]]]==True,AppendTo[fxList,#]]&/@Drop[fList,1];
(*Partition[Reverse[Drop[orSeqList,{Length[orSeqList]}]],3,1]*)
newbub=CoalescingOrClosePackingFunctions`InteractTrips[Reverse[sequenceList2],Join[{{{pTip[[1]],1},Last[orSeqList]}},Partition[Join[{{pTip[[1]],1}},Reverse[orSeqList]],3,1]],newbub,precisionFactor,fxList,1];
(*Print[SmallFunctions`Drawcol[newbub]];*)
ambCol=newbub[[pTip[[5]]]];
(*CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi+1,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,1][[1]];*)
distP=ambCol[[First[orSeqList][[2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=2,dp<=Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[1]],1]][[1]]+distP;
newbub[[pTip[[5]]]]=ambCol;


fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]]),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*then it close packs the trip*)

newbub=CoalescingOrClosePackingFunctions`InteractTrips[sequenceList2,Partition[Join[{{pTip[[4]],1}},orSeqList],3,1],newbub,precisionFactor,fxList,1];
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];
];
AppendTo[stList,{pTip[[5]],orSeqList[[pi,2]]}];

(*Print[SmallFunctions`Drawcol[newbub]];*)
pi++;
];

(*close packs the whole amb column*)
(*close packs the whole amb column*)
(*newbub2=Map[Function[pp,newbub[[pp]]],{pTip[[2]],pTip[[4]],pTip[[5]]}];
fList=Map[Last,Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub2,newbub2[[1,1]],precisionFactor, 4]]]];
fxList={};
Map[Function[mem,If[MemberQ[{1,2},mem[[1]]]\[Equal]True,
AppendTo[fxList,mem]]],fList];
If[MemberQ[fxList,{3,pos[[fp]]}]\[Equal]False, AppendTo[fxList,{3,pos[[fp]]}]];
newbub2=CoalescingOrClosePackingFunctions`CoalesceORclosePackBubbles[newbub2,precisionFactor,fxList,2];
newbub[[pTip[[5]]]]=newbub2[[3]];*)



(*this section reutilises all the trips and closepaccks the whole column,but this is not necessary until there are at least 4 plates*)
If[pn>3,

fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,newbub[[pTip[[2]],1]],precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[1;;4]],#[[1]]]==True,
AppendTo[fxList,#]]&/@fList;
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*newbub2=CoalescingOrClosePackingFunctions`CoalesceORclosePackBubbles[newbub2,precisionFactor,fxList,2];*)
ngl=NeighbourFindingFunctions`GetFinalTripList[newbub,precisionFactor,{{pTip[[2]],1}}];
newbub=CoalescingOrClosePackingFunctions`InteractTrips[ngl[[3]],keepNeigh,newbub,precisionFactor,fxList,1];

If[((pn-pi ==0)&&(fplates==1)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
distList2=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll2=Last[Last/@Sort@Transpose[distList2]];
lc2=Max[First/@Sort@Transpose[distList2]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*Print["***",EuclideanDistance[pao[[2,1]],pao[[1,1]]]];*)
If[lc2<EuclideanDistance[pao[[2,1]],pao[[1,1]]],
mp=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]-lc2)/(2fpN);
ambCol=newbub[[pTip[[5]]]];
For[pf=1,pf<=(fpN),
ambCol[[Length[ambCol]-pf,2]]=ambCol[[Length[ambCol]-pf,2]]+{mp,mp};
pf++;
];
newbub[[pTip[[5]]]]=ambCol;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
If[(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
];
];

]

(*
newbub[[pTip[[5]]]]=newbub2[[3]];*)
(*Print[SmallFunctions`Drawcol[newbub]];*)

];

{newbub,fplates}
]


GetPlateSizeforAmbCol1[allbubList_,precisionFactor_,ambAng_,info_, npAng_,gZ_,pao1_,opt_,fopt_,fpN_,fixedP_,fpl_]:=Module[{m,p,i,r ,temp,anbOfC,nlc,angS,newbub,ambCol,aplate,ngl,fList,sequenceList,sequenceList2,finalTrips,n2, allSeqIn, trip,str,pTip,pn,distList,lc,fxList,sides,pos,orderS,sd,fp,pi,orSeqList,pao,nfList, an, pt, range,ll,rotA, alpha,newbub2,tempN,tempT,per,lc1,ambitus,fplates,hd,mp,pf,ll2,lc2,distList2,rp,distP,dp,stList,keepNeigh,abV},
newbub=allbubList;
pao=pao1;
fplates=fixedP;
keepNeigh={};
(*location of all the different types of plates*)
pTip = Flatten[If[MemberQ[info,#]==True,Position[info,#],-1]&/@{6,5,4,3,2,1}];
abV=1;
(*gets the side for the newest plate*)
sides=getPlateSide[ambAng[[1]]/2,#,pao]&/@newbub[[pTip[[5]]]];
(*decides which side the new plate is on based on plate number*)
(*get plate number*)
pn=Length[newbub[[pTip[[5]]]]];
If[EvenQ[pn]==True,sd=2,sd=1];
(* get the distance of the column*)
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
(*farthest plate*)
ll=Last[Last/@Sort@Transpose[distList]];
(*length of column, which is the distance from the apical system to the peristome, so take the distance from the center of the apical system and the center of the plate then i need to add the radius of the last plate and the radius of the peristome*)
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
lc1=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*decides if the apical system grows based on the length of the column, the apical system changes size ONLY if it can increase it doesnt decrease*)
(**********************************)
(*newbub=GrowApiPer[newbub,pTip,lc,gZ,ambAng,{6,5,3,4,2,1}];
(*updates the pao list*)

newbub=GrowApiPer[newbub,gZ,ambAng,info,precisionFactor];
pao=Map[Function[dummy,If[dummy==-1,{},newbub[[dummy,1]]]],Take[pTip,4]];
lc=Max[Map[First,Sort[Transpose[distList]]]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
lc1=Max[Map[First,Sort[Transpose[distList]]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];*)
(*gets ambitus location from the apical system...distance*)
ambitus=(lc/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
r=0;
(*the length is adjusted to match the angle*)
nlc=Sqrt[(lc^2)+((lc*Tan[ambAng[[1]]/2])^2)];
distList=Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,newbub[[pTip[[2]],1]],precisionFactor, 4]]];
(*sequenceList=getOrderOfPlates[distList,newbub,precisionFactor,pTip,pn,pao,ambAng[[1]]];*)
Print["dis",distList];
sequenceList={};
If[(#[[1]]==pTip[[5]])&&(MemberQ[sequenceList,#]==False),AppendTo[sequenceList,#];]&/@Map[Last,distList];
(*sequenceList=Reverse[Sort[sequenceList]];*)
(*gets the position of the plates in the list to find the new plate*)
pos=Map[Last,sequenceList];
(*uses the position to determin the side of the plates and eventually determine the newest plate's location*)
orderS=Map[Function[k,sides[[k]]],pos];
(*position of the newest plate*)
fp=Flatten[Position[orderS, sd]][[1]];
(*drops the newest plate and then prepends it to the front of the list*)
orSeqList=Drop[sequenceList,{fp}];
Print[orSeqList];
PrependTo[orSeqList,{pTip[[5]],pos[[fp]]}];
orSeqList=Reverse[Sort[sequenceList]];
Print[orSeqList];
(*the order list is important to allow the plates to move in order to their location*)
pi=1;
rp=0;
stList={{pTip[[4]],1}};
While[pi<=pn,
(*get the ambcol only*)
ambCol=newbub[[pTip[[5]]]];
(*takes the plate of interest*)
aplate=ambCol[[orSeqList[[pi,2]]]];
(*gets the distance from the apical system*)
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
abV=1;
temp=r;
If[((p>anbOfC)&&(fplates==0))||((fplates==1)&&(pn+1-pi <= fpN)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
abV=2;
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
If[((fopt==1 )&& (pn+1-pi ==fpN)),
Print["Fixed ",pi];
fplates=1;
hd=EuclideanDistance[pao[[2,1]],ambCol[[orSeqList[[pi-1,2]],1]]];
Print[ambCol[[orSeqList[[pi-1,2]]]][[1]]];
ll2=hd+(hd-SmallFunctions`MyaveFn[pao[[2,2]]]) +SmallFunctions`MyaveFn[pao[[1,2]]](*+SmallFunctions`MyaveFn[pao[[3,2]]]*);
If[ll2>EuclideanDistance[pao[[2,1]],pao[[1,1]]],
pao[[1,1]]=pao[[2,1]]-{0,ll2};
newbub[[pTip[[1]],1]]=pao[[1]];
ambitus=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
,rp=1;
];
];

p=SmallFunctions`DistancebtwPoints[pao[[1,1]],aplate[[1]]];
r=SmallFunctions`CenterDistance[Abs[p],Abs[p],angS];
,
(*ONLY IF PLATES ARE FIXED*)
If[(fplates==1)&&(pi<=( pn-fpl)),
(*this used for sand dollars, it switches between petal and non petal angle*)
If[((pi==1)),angS=ambAng[[2]]*0.3/2;,angS=ambAng[[2]]/2;];
angS=ambAng[[2]]/2;,
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
];
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
If[((pi==1))&& (opt==1),
(*first amb plate is calculated by descartes if opt \[Equal]1*)
r=DescartesFunctions`DescartesTheorem[SmallFunctions`MyaveFn[pao[[1,2]]],SmallFunctions`MyaveFn[pao[[2,2]]],SmallFunctions`MyaveFn[pao[[3,2]]]]*2;
,
r=SmallFunctions`CenterDistance[p,p,angS];
];

];

If[rp==0,aplate[[2]]={r/2,r/2}];
ambCol[[orSeqList[[pi,2]]]]=aplate;
newbub[[pTip[[5]]]]=ambCol;

(*Print[SmallFunctions`Drawcol[newbub]];*)
If[pi==1,

(*angle btw occular and apical system*)
pt=SmallFunctions`AngleAroundThePlate[pao[[3,1]]-pao[[2,1]]];
(*angle location of a plate relative to the apical system center*)
an=SmallFunctions`AngleAroundThePlate[aplate[[1]]-pao[[2,1]]];
alpha=SmallFunctions`CosOfAngleC[p,p,r/2];
Print[alpha];
(*finds the amount and direction a plate must rotate to its new location*)
rotA=If[an> pt,(pt+alpha),(pt-alpha)];
Print[rotA];
(*gets the difference it needs to move from the original location*)
rotA=an-rotA;
Print[rotA];
aplate[[1]]=SmallFunctions`RotateOneCurve[aplate[[1]],rotA,pao[[2,1]]];
ambCol[[orSeqList[[pi,2]]]]=aplate;
(*first amb plate always interacts with the occular plate*)
ambCol=CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,0][[1]];
Print[SmallFunctions`Drawcol[newbub]];
If[pn>1,
distP=ambCol[[orSeqList[[pi+1,2]],1]];
ambCol=CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi+1,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,1][[1]];
distP=ambCol[[orSeqList[[pi+1,2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=pi+2,dp<=Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
];
newbub[[pTip[[5]]]]=ambCol;

,

(*gets the sequence based on the original list*)
(*tempT=GetATripForThePlate[newbub, orSeqList,pao,pos, aplate,fp,ambAng[[1]],pTip,precisionFactor,10];
trip=tempT[[1]];
sequenceList2=tempT[[2]];
fxList=tempT[[3]];
*)
(*gets the sequence list and the fixed List to closepack*)
sequenceList2=NeighbourFindingFunctions`GetASequenceForCol[newbub,{{pTip[[2]],1}},precisionFactor];
fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,aplate,precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]])||((#[[1]]==pTip[[5]])&&(Flatten[Position[orSeqList,#],1][[1]]<Flatten[Position[orSeqList,fList[[1]]],1][[1]])),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*
Print["f",fxList];
Print["s",sequenceList2];
Print["t",trip];*)
(*Print["FXLIST",fxList];*)
(*if the old list doesnt produce any trip then we use the new list*)
(*If[trip\[Equal]{},
newbub2=newbub;
tempT=GetATripForThePlate[allbubList, orSeqList,pao,pos, aplate,fp,ambAng[[1]],pTip,precisionFactor];
trip=tempT[[1]];
sequenceList2=tempT[[2]];
fxList=tempT[[3]];
];
*)
(*then it close packs the trip*)


distP=ambCol[[orSeqList[[pi,2]],1]];
trip={Join[Take[stList,If[pi>2,-2,-1]],{{pTip[[5]],orSeqList[[pi,2]]}}]};
AppendTo[keepNeigh,trip[[1]]];
(*Print["st",stList];
Print["k",keepNeigh];
Print["o",orSeqList];
Print["t",trip];*)

tempN={1,newbub};
tempN=CoalescingOrClosePackingFunctions`FnthatCPorCoalesce[trip[[1]],newbub,tempN[[2]], {trip[[1]]},sequenceList2,precisionFactor,fxList,fxList,1];
newbub=tempN[[2]];

(*this readjusts the size if the distance changes*)
ambCol=newbub[[pTip[[5]]]];
p=SmallFunctions`DistancebtwPoints[#[[1]],ambCol[[orSeqList[[pi,2]],1]]]&@If[abV==1,pao[[2]],pao[[1]]];
r=SmallFunctions`CenterDistance[p,p,angS];
ambCol[[orSeqList[[pi,2]],2]]={r/2,r/2};
newbub[[pTip[[5]]]]=ambCol;


(*then closepacks again*)
tempN={1,newbub};
tempN=CoalescingOrClosePackingFunctions`FnthatCPorCoalesce[trip[[1]],newbub,tempN[[2]], {trip[[1]]},sequenceList2,precisionFactor,fxList,fxList,1];
newbub=tempN[[2]];

(*moves the other plates to match the changes, so the whole column maintians relative position*)
If[pi>2,
ambCol=newbub[[pTip[[5]]]];
distP=ambCol[[orSeqList[[pi,2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=pi+1,dp<=Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
newbub[[pTip[[5]]]]=ambCol;
];
(*Print[SmallFunctions`Drawcol[newbub]];*)
If[((pn-pi ==0)&&(fplates==1)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
distList2=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll2=Last[Last/@Sort@Transpose[distList2]];
lc2=Max[First/@Sort@Transpose[distList2]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*Print["***",EuclideanDistance[pao[[2,1]],pao[[1,1]]]];*)
If[lc2<EuclideanDistance[pao[[2,1]],pao[[1,1]]],
mp=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]-lc2)/(2fpN);
ambCol=newbub[[pTip[[5]]]];
For[pf=1,pf<=(fpN),
ambCol[[Length[ambCol]-pf,2]]=ambCol[[Length[ambCol]-pf,2]]+{mp,mp};
pf++;
];
newbub[[pTip[[5]]]]=ambCol;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
If[(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
];
];

];

distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];
(*Print[SmallFunctions`Drawcol[newbub]];*)
];
AppendTo[stList,{pTip[[5]],orSeqList[[pi,2]]}];

(*Print[SmallFunctions`Drawcol[newbub]];*)
pi++;
];

(*close packs the whole amb column*)
(*close packs the whole amb column*)
(*newbub2=Map[Function[pp,newbub[[pp]]],{pTip[[2]],pTip[[4]],pTip[[5]]}];
fList=Map[Last,Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub2,newbub2[[1,1]],precisionFactor, 4]]]];
fxList={};
Map[Function[mem,If[MemberQ[{1,2},mem[[1]]]\[Equal]True,
AppendTo[fxList,mem]]],fList];
If[MemberQ[fxList,{3,pos[[fp]]}]\[Equal]False, AppendTo[fxList,{3,pos[[fp]]}]];
newbub2=CoalescingOrClosePackingFunctions`CoalesceORclosePackBubbles[newbub2,precisionFactor,fxList,2];
newbub[[pTip[[5]]]]=newbub2[[3]];*)
(*this section reutilises all the trips and closepaccks the whole column,but this is not necessary until there are at least 4 plates*)
If[pn>3,

fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,newbub[[pTip[[2]],1]],precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[1;;4]],#[[1]]]==True,
AppendTo[fxList,#]]&/@fList;
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*newbub2=CoalescingOrClosePackingFunctions`CoalesceORclosePackBubbles[newbub2,precisionFactor,fxList,2];*)
ngl=NeighbourFindingFunctions`GetFinalTripList[newbub,precisionFactor,{{pTip[[2]],1}}];
newbub=CoalescingOrClosePackingFunctions`InteractTrips[ngl[[3]],keepNeigh,newbub,precisionFactor,fxList,1];

If[((pn-pi ==0)&&(fplates==1)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
distList2=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll2=Last[Last/@Sort@Transpose[distList2]];
lc2=Max[First/@Sort@Transpose[distList2]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*Print["***",EuclideanDistance[pao[[2,1]],pao[[1,1]]]];*)
If[lc2<EuclideanDistance[pao[[2,1]],pao[[1,1]]],
mp=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]-lc2)/(2fpN);
ambCol=newbub[[pTip[[5]]]];
For[pf=1,pf<=(fpN),
ambCol[[Length[ambCol]-pf,2]]=ambCol[[Length[ambCol]-pf,2]]+{mp,mp};
pf++;
];
newbub[[pTip[[5]]]]=ambCol;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
If[(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
];
];

]

(*
newbub[[pTip[[5]]]]=newbub2[[3]];*)
(*Print[SmallFunctions`Drawcol[newbub]];*)

];

{newbub,fplates}
]


GetPlateSizeforAmbCol[allbubList_,precisionFactor_,ambAng_,info_, npAng_,gZ_,pao1_,opt_,fopt_,fpN_,fixedP_,fpl_]:=Module[{m,p,i,r ,temp,anbOfC,nlc,angS,newbub,ambCol,aplate,ngl,fList,sequenceList,sequenceList2,finalTrips,n2, allSeqIn, trip,str,pTip,pn,distList,lc,fxList,sides,pos,orderS,sd,fp,pi,orSeqList,pao,nfList, an, pt, range,ll,rotA, alpha,newbub2,tempN,tempT,per,lc1,ambitus,fplates,hd,mp,pf,ll2,lc2,distList2,rp,distP,dp,stList,keepNeigh,abV},
newbub=allbubList;
pao=pao1;
fplates=fixedP;
keepNeigh={};
(*location of all the different types of plates*)
pTip = Flatten[If[MemberQ[info,#]==True,Position[info,#],-1]&/@{6,5,4,3,2,1}];
abV=1;
(*gets the side for the newest plate*)
sides=getPlateSide[ambAng[[1]]/2,#,pao]&/@newbub[[pTip[[5]]]];
(*decides which side the new plate is on based on plate number*)
(*get plate number*)
pn=Length[newbub[[pTip[[5]]]]];
If[EvenQ[pn]==True,sd=2,sd=1];
(* get the distance of the column*)
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
(*farthest plate*)
ll=Last[Last/@Sort@Transpose[distList]];
(*length of column, which is the distance from the apical system to the peristome, so take the distance from the center of the apical system and the center of the plate then i need to add the radius of the last plate and the radius of the peristome*)
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
lc1=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*gets ambitus location from the apical system...distance*)
ambitus=(lc/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
r=0;
(*the length is adjusted to match the angle*)
nlc=Sqrt[(lc^2)+((lc*Tan[ambAng[[1]]/2])^2)];
distList=Sort[Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,newbub[[pTip[[2]],1]],precisionFactor, 4]]];
(*sequenceList=getOrderOfPlates[distList,newbub,precisionFactor,pTip,pn,pao,ambAng[[1]]];*)

sequenceList={};
If[(#[[1]]==pTip[[5]])&&(MemberQ[sequenceList,#]==False),AppendTo[sequenceList,#];]&/@Map[Last,distList];
(*sequenceList=Reverse[Sort[sequenceList]];*)
(*gets the position of the plates in the list to find the new plate*)
pos=Map[Last,sequenceList];
(*uses the position to determin the side of the plates and eventually determine the newest plate's location*)
orderS=Map[Function[k,sides[[k]]],pos];
(*position of the newest plate*)
fp=Flatten[Position[orderS, sd]][[1]];
orSeqList=Reverse[Sort[sequenceList]];
(*the order list is important to allow the plates to move in order to their location*)
pi=1;
rp=0;
stList={{pTip[[4]],1}};
While[pi<=pn,
(*get the ambcol only*)
ambCol=newbub[[pTip[[5]]]];
(*takes the plate of interest*)
aplate=ambCol[[orSeqList[[pi,2]]]];
(*gets the distance from the apical system*)
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
abV=1;
temp=r;
If[((p>anbOfC)&&(fplates==0))||((fplates==1)&&(pn+1-pi <= fpN)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
abV=2;
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
If[((fopt==1 )&& (pn+1-pi ==fpN)),
Print["Fixed ",pi];
fplates=1;
hd=EuclideanDistance[pao[[2,1]],ambCol[[orSeqList[[pi-1,2]],1]]];

ll2=hd+(hd-SmallFunctions`MyaveFn[pao[[2,2]]]) +SmallFunctions`MyaveFn[pao[[1,2]]](*+SmallFunctions`MyaveFn[pao[[3,2]]]*);
If[ll2>EuclideanDistance[pao[[2,1]],pao[[1,1]]],
pao[[1,1]]=pao[[2,1]]-{0,ll2};
newbub[[pTip[[1]],1]]=pao[[1]];
ambitus=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]/2);
anbOfC=Sqrt[(((ambitus))^2)+((((ambitus))*Tan[ambAng[[1]]/2])^2)];
,rp=1;
];
];

p=SmallFunctions`DistancebtwPoints[pao[[1,1]],aplate[[1]]];
r=SmallFunctions`CenterDistance[Abs[p],Abs[p],angS];
,
(*ONLY IF PLATES ARE FIXED*)
If[(fplates==1)&&(pi<=( pn-fpl)),
(*this used for sand dollars, it switches between petal and non petal angle*)
If[((pi==1)),angS=ambAng[[2]]*0.3/2;,angS=ambAng[[2]]/2;];
angS=ambAng[[2]]/2;,
If[((pi==1)),angS=npAng;,angS=ambAng[[1]]/2;];
angS=ambAng[[1]]/2;
];
p=SmallFunctions`DistancebtwPoints[pao[[2,1]],aplate[[1]]]; 
If[((pi==1))&& (opt==1),
(*first amb plate is calculated by descartes if opt \[Equal]1*)
r=DescartesFunctions`DescartesTheorem[SmallFunctions`MyaveFn[pao[[1,2]]],SmallFunctions`MyaveFn[pao[[2,2]]],SmallFunctions`MyaveFn[pao[[3,2]]]]*2;
,
r=SmallFunctions`CenterDistance[p,p,angS];
];

];
If[rp==0,aplate[[2]]={r/2,r/2}];ambCol[[orSeqList[[pi,2]]]]=aplate;
newbub[[pTip[[5]]]]=ambCol;

If[((pn-pi ==0)&&(fplates==1)),
(*if the distance is greater than the ambitus location then it puts the plate on the peristomal surface*)
distList2=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll2=Last[Last/@Sort@Transpose[distList2]];
lc2=Max[First/@Sort@Transpose[distList2]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
(*Print["***",EuclideanDistance[pao[[2,1]],pao[[1,1]]]];*)
If[lc2<EuclideanDistance[pao[[2,1]],pao[[1,1]]],
mp=(EuclideanDistance[pao[[2,1]],pao[[1,1]]]-lc2)/(2fpN);
ambCol=newbub[[pTip[[5]]]];
For[pf=1,pf<=(fpN),
ambCol[[Length[ambCol]-pf,2]]=ambCol[[Length[ambCol]-pf,2]]+{mp,mp};
pf++;
];
newbub[[pTip[[5]]]]=ambCol;
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];
If[(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
];
];

];

distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];
If[pi==1,
(*works for int,pt=SmallFunctions`AngleAroundThePlate[pao[[4,1]]-pao[[2,1]]];
Print[pt];
(*angle location of a plate relative to the apical system center*)
an=SmallFunctions`AngleAroundThePlate[aplate[[1]]-pao[[2,1]]];
Print[an];
(*this needs works i need to figure out the pattern for different angles*)
alpha=SmallFunctions`CosOfAngleC[p,p,If[ambAng[[1]]<0.55,ambAng[[1]]r,If[(ambAng[[1]]<0.55),ambAng[[1]]1.2r,ambAng[[1]]2.1r]]];
Print[alpha];
alpha=SmallFunctions`CosOfAngleC[p,p,r];
Print[alpha];
(*finds the amount and direction a plate must rotate to its new location*)
rotA=If[an> pt,(pt+alpha),(pt-alpha)];
(*gets the difference it needs to move from the original location*)
rotA=If[an> pt,1,-1]Abs[an-rotA];*)
(*angle btw occular and apical system*)
pt=SmallFunctions`AngleAroundThePlate[pao[[3,1]]-pao[[2,1]]];
(*angle location of a plate relative to the apical system center*)
an=SmallFunctions`AngleAroundThePlate[aplate[[1]]-pao[[2,1]]];
rotA=EuclideanDistance[pao[[3,1]],pao[[2,1]]];
(*angle location of a plate relative to the apical system center*)
alpha=EuclideanDistance[aplate[[1]],pao[[2,1]]];
(*aplate[[1]]=(pao[[3,1]]+{If[an> pt,ambAng[[1]]/2*0.3r,-ambAng[[1]]/2*0.3r],-Abs[rotA-alpha]});
aplate[[1]]=(pao[[3,1]]+{If[an> pt,Mean[pao[[3,2]]]/2.5,-Mean[pao[[3,2]]]/2.5],-Abs[rotA-alpha]});*)
aplate[[1]]=(pao[[3,1]]+{If[an> pt,Sin[ambAng[[1]]],-Sin[ambAng[[1]]]]Abs[rotA-alpha],-Abs[rotA-alpha]});
(*this needs works i need to figure out the pattern for different angles*)
(*alpha=SmallFunctions`CosOfAngleC[p,p,0.3r];
Print[alpha];
(*alpha=SmallFunctions`CosOfAngleC[p,p,If[ambAng[[1]]<0.55,ambAng[[1]]r,If[(ambAng[[1]]<0.55),ambAng[[1]]1.2r,ambAng[[1]]2.1r]]];
Print[alpha];*)
(*alpha=SmallFunctions`CosOfAngleC[p,p,0.3r];
Print[alpha];*)
(*finds the amount and direction a plate must rotate to its new location*)
rotA=If[an> pt,(pt+alpha),(pt-alpha)];
(*gets the difference it needs to move from the original location*)
rotA=If[an\[GreaterEqual] rotA,1,-1]Abs[(an-rotA)];
rotA=If[an> pt,(+alpha),(-alpha)];
rotA=If[an> pt,(+ambAng[[1]]*0.3),(ambAng[[1]]*0.3)];
Print["rrrrr->>",rotA];
Print[ambAng[[1]]/2*0.3];
aplate[[1]]=SmallFunctions`RotateOneCurve[aplate[[1]],rotA,pao[[2,1]]];*)
(*first amb plate always interacts with the occular plate*)
ambCol[[orSeqList[[pi,2]]]]=aplate;
ambCol=CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,0][[1]];
newbub[[pTip[[5]]]]=ambCol;
(*
If[(pn>1&&pi>1),

sequenceList2=Join[{{pTip[[2]],1}},{{pTip[[4]],1}},orSeqList,{{pTip[[1]],1}}];
fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,aplate,precisionFactor, 4]];
fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]\[Equal]True,
If[(#[[1]]\[NotEqual] pTip[[5]])||((#[[1]]\[Equal]pTip[[5]])&&(Flatten[Position[orSeqList,#],1][[1]]<Flatten[Position[orSeqList,fList[[1]]],1][[1]])),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]\[Equal]False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*then it close packs the trip*)
distP=ambCol[[orSeqList[[pi,2]],1]];

newbub=CoalescingOrClosePackingFunctions`InteractTrips[sequenceList2,Partition[Join[{{pTip[[4]],1}},orSeqList],3,1],newbub,precisionFactor,fxList,1];
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates\[Equal]0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];
ambCol=newbub[[pTip[[5]]]];
distP=ambCol[[First[orSeqList][[2]],1]];
(*Drop[orSeqList,{Length[orSeqList]}]]*)
fxList={};
If[MemberQ[pTip[[3;;5]],#[[1]]]\[Equal]True,AppendTo[fxList,#]]&/@Drop[fList,1];
newbub=CoalescingOrClosePackingFunctions`InteractTrips[Reverse[sequenceList2],Join[{{{pTip[[1]],1},Last[orSeqList]}},Partition[Reverse[orSeqList],3,1]],newbub,precisionFactor,fxList,1];
ambCol=newbub[[pTip[[5]]]];
(*CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi+1,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,1][[1]];*)
distP=ambCol[[First[orSeqList][[2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=2,dp\[LessEqual]Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[1]],1]][[1]]+distP;
newbub[[pTip[[5]]]]=ambCol;

];*)
];
newbub[[pTip[[5]]]]=ambCol;
pi++;

];
If[pn>1,
sequenceList2=Join[{{pTip[[2]],1}},{{pTip[[4]],1}},orSeqList,{{pTip[[1]],1}}];
(*sequenceList2=NeighbourFindingFunctions`GetFinalTripList[newbub,precisionFactor,{{pTip[[2]],1}}][[3]];*)
sequenceList2=NeighbourFindingFunctions`GetASequenceForCol[newbub,{{pTip[[2]],1}},precisionFactor];

fList=Last/@Sort@Transpose[NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[newbub,aplate,precisionFactor, 4]];
fxList={};

If[MemberQ[pTip[[2;;5]],#[[1]]]==True,
If[(#[[1]]!= pTip[[5]]),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]==False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*then it close packs the trip*)

newbub=CoalescingOrClosePackingFunctions`InteractTrips[sequenceList2,Partition[Join[{{pTip[[4]],1}},orSeqList],3,1],newbub,precisionFactor,fxList,1];
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates==0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];

ambCol=newbub[[pTip[[5]]]];
(*distP=ambCol[[First[orSeqList][[2]],1]];
fxList={};
(*If[MemberQ[pTip[[2;;4]],#[[1]]]\[Equal]True,AppendTo[fxList,#]]&/@Drop[fList,1];
(*Partition[Reverse[Drop[orSeqList,{Length[orSeqList]}]],3,1]*)
newbub=CoalescingOrClosePackingFunctions`InteractTrips[Reverse[sequenceList2],Join[{{{pTip[[1]],1},Last[orSeqList]}},Partition[Join[{{pTip[[1]],1}},Reverse[orSeqList]],3,1]],newbub,precisionFactor,fxList,1];*)
(*Print[SmallFunctions`Drawcol[newbub]];*)
ambCol=newbub[[pTip[[5]]]];
(*CoalescingOrClosePackingFunctions`Move2Bubbles[{{2,1},{1,orSeqList[[pi+1,2]]}}, {ambCol,{pao[[3]]}},{ambCol,{pao[[3]]}},{{2,1}},{{2,1}},precisionFactor, 2,1][[1]];*)
distP=ambCol[[First[orSeqList][[2]],1]]-distP;
(*this moves the whole column down*)
dp=1;
For[dp=2,dp\[LessEqual]Length[orSeqList],
ambCol[[orSeqList[[dp,2]],1]]=ambCol[[orSeqList[[dp,2]],1]]+distP;
dp++;
];
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[1]],1]][[1]]+distP;
newbub[[pTip[[5]]]]=ambCol;


fxList={};
If[MemberQ[pTip[[2;;5]],#[[1]]]\[Equal]True,
If[(#[[1]]\[NotEqual] pTip[[5]]),AppendTo[fxList,#]]]&/@Drop[fList,1];
If[MemberQ[fxList,{pTip[[5]],pos[[fp]]}]\[Equal]False, AppendTo[fxList,{pTip[[5]],pos[[fp]]}]];
(*then it close packs the trip*)

newbub=CoalescingOrClosePackingFunctions`InteractTrips[sequenceList2,Partition[Join[{{pTip[[4]],1}},orSeqList],3,1],newbub,precisionFactor,fxList,1];
distList=NeighbourFindingFunctions`NeighBourFinderBasedOnDistance[{newbub[[#[[2]]]],newbub[[#[[5]]]]},newbub[[#[[2]],1]],precisionFactor, 4]&@pTip;
ll=Last[Last/@Sort@Transpose[distList]];
lc=Max[First/@Sort@Transpose[distList]]+SmallFunctions`MyaveFn[ pao[[1,2]]]+SmallFunctions`MyaveFn[newbub[[pTip[[5]],ll[[2]]]][[2]]];


If[fplates\[Equal]0||(lc>EuclideanDistance[pao[[2,1]],pao[[1,1]]]),
(*{m,(p)*Cos[ambAng[[1]]/2],(p-(r/2))};*)
(*Print["*********************"];
Print[SmallFunctions`Drawcol[newbub]];*)
newbub[[pTip[[1]],1]][[1]]=newbub[[pTip[[2]],1]][[1]]-{0,lc};
(*Print[SmallFunctions`Drawcol[newbub]];
Print["*********************"];*)
];*)
];

(*Print[SmallFunctions`Drawcol[newbub]];*)

{newbub,fplates}
]


GrowthOfAmbZone[allBubbleList_,infoList_,precisionFactor_,gZ_,ambAng_:{Pi/10,Pi/10},npAng_:(9*Pi/180),fopt_,fpN_,fixedP_,fpl_]:=Module[{newbub, tempi,  pTip,pao, pn,n3,distList, ll, lc, n4,n6,st,fPlates,tempN},
(*find position of peristome =6 , apical system=5 and occular=3*)
newbub=allBubbleList;
tempi=infoList;
fPlates=fixedP;
(*gets the position of the different types of plates*)
pTip = Flatten[If[MemberQ[tempi,#]==True,Position[tempi,#],-1]&/@{6,5,3,4,2,1}];
pao=If[#==-1,{},newbub[[#,1]]]&/@Take[pTip,4];
(*plate number int and amb*)
pn=If[#==-1,0,Length[newbub[[#]]]]&/@Take[pTip,{-2}];
tempN=GetPlateSizeforAmbCol[newbub,precisionFactor,ambAng,infoList,(npAng),gZ,pao,0,fopt,fpN,fixedP,fpl];
newbub=tempN[[1]];
fPlates=tempN[[2]];
pao=If[#==-1,{},newbub[[#,1]]]&/@Take[pTip,4];
n3=newbub[[pTip[[5]]]];
If[pTip[[1]]==-1,PrependTo[newbub,{pao[[1]]}];PrependTo[tempi,6];,newbub[[pTip[[1]],1]]=pao[[1]];];
{newbub,tempi,fPlates}
]



GrowthOfIntZone[allBubbleList_,infoList_,precisionFactor_,gZ_,ambAng_:{Pi/10,Pi/10},npAng_:(9*Pi/180),fnp_:0,fplate_:0]:=Module[{newbub, tempi, fn, fn1, fn2, pTip,pao, pn,n3,lc,n4,lc1,ambitus},
(*find position of peristome =6 , apical system=5 and occular=3*)
newbub=allBubbleList;
tempi=infoList;
(*gets the position of the different types of plates*)
pTip = Flatten[If[MemberQ[tempi,#]==True,Position[tempi,#],-1]&/@{6,5,3,4,2,1}];
pao=If[#==-1,{},newbub[[#,1]]]&/@Take[pTip,4];
(*plate number int and amb*)
pn=If[#==-1,0,Length[newbub[[#]]]]&/@Take[pTip,{-2}];
n3=newbub[[pTip[[5]]]];
(*gets the length of the column*)
lc=EuclideanDistance[pao[[1,1]],pao[[2,1]]];
lc=Sqrt[(lc^2)+((lc*Tan[ambAng[[1]]/2])^2)];
lc1=lc-SmallFunctions`MyaveFn[ pao[[1,2]]];
(*estimates the number of int plates relative to columns length*)
ambitus=(lc/2);

lc=EuclideanDistance[pao[[1,1]],pao[[2,1]]];

n4=GetPlateSizeforIntCol[{ {pao[[2]]},{pao[[1]]},n3,{pao[[3]]},newbub[[pTip[[4]]]]},precisionFactor,ambAng[[1]],gZ- ambAng[[1]],lc,(ambitus),Length[newbub[[pTip[[5]]]]],SmallFunctions`MyaveFn[ pao[[1,2]]],(ambAng[[1]]-npAng)/2,pao,1,fnp,fplate];

AppendTo[newbub,Flatten[n4[[1]],1]];
AppendTo[tempi,1];
{newbub,tempi,n4[[2]],n4[[3]]}
]



GrowThenCoalesceORclosePackBubbles[allBubbleList_,precisionFactor_,infoList_,gZAng_: (2Pi/5),ambAng_:{Pi/10,Pi/10},npAng_:(9*Pi/180),fopt_: 0,fpN_:0,fixedP_:0,fpl_:0]:=Module[{newBubbleList,nb},
newBubbleList= allBubbleList;
If[SmallFunctions`NumOfPlates[newBubbleList]==0,
newBubbleList,
nb=GrowthOfAmbZone[newBubbleList,infoList,precisionFactor,(gZAng),ambAng,npAng,fopt,fpN,fixedP,fpl];

(*Print[SmallFunctions`Drawcol[GrowthOfIntZone[nb[[1]],nb[[2]],precisionFactor,(gZAng),ambitusPer,ambAng,npAng][[1]]]];*)
nb
]
]


End[]


Protect[Evaluate[$Context<>"*"]];


EndPackage[]
